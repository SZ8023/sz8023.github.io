<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ForYou</title>
  <subtitle>如果一个人活得很诚恳，那么他一定生活在别处</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sz8023.github.io/"/>
  <updated>2016-10-25T08:01:37.000Z</updated>
  <id>http://sz8023.github.io/</id>
  
  <author>
    <name>styshy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Xcode8相关问题汇总</title>
    <link href="http://sz8023.github.io/2016/09/22/iOS-20160922Xcode8%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://sz8023.github.io/2016/09/22/iOS-20160922Xcode8相关问题汇总/</id>
    <published>2016-09-22T01:14:46.000Z</published>
    <updated>2016-10-25T08:01:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天很多苹果开发的小伙伴迫不及待的升级了Xcode8，可是升级完成之后项目中也遇到了很多小问题，下面就一一列举相关问题。</p>
<p>如果你的项目中访问了相机，相册，麦克风等设备，你需要在info.plist文件里做先关配置，如果没有配置相关信息，程序会直接退出。</p>
<h5 id="访问相机"><a href="#访问相机" class="headerlink" title="访问相机"></a><a href="https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html" target="_blank" rel="external">访问相机</a></h5><blockquote>
<p>Important: To protect user privacy, an iOS app linked on or after iOS 10.0, and which accesses the device’s camera, must statically declare the intent to do so. Include the NSCameraUsageDescription key in your app’s Info.plist file and provide a purpose string for this key. If your app attempts to access the device’s camera without a corresponding purpose string, your app exits.</p>
</blockquote>
<p>根据苹果的描述信息，你需要在info.plist文件里面做相关配置。</p>
<p>```objc</p>
<p><key>NSCameraUsageDescription</key></p>
<p><string>允许此权限才能使用相机</string><br>```</p>
<h5 id="访问相册"><a href="#访问相册" class="headerlink" title="访问相册"></a>访问相册</h5><p>此处相关链接可以参考访问相机，以下连接相同。</p>
<p>```objc</p>
<p><key>NSPhotoLibraryUsageDescription</key></p>
<p><string>允许此权限才能访问相册</string><br>```</p>
<h5 id="访问麦克风"><a href="#访问麦克风" class="headerlink" title="访问麦克风"></a>访问麦克风</h5><a id="more"></a>
<p>```objc</p>
<p><key>NSMicrophoneUsageDescription</key></p>
<p><string>允许此权限才能使用麦克风</string><br>```</p>
<p>还有其他的权限，比如媒体库，蓝牙，日历，健康等，更多权限参考<a href="https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html" target="_blank" rel="external">Information Property List Key Reference</a></p>
<h5 id="Xcode8禁止控制台打印干扰信息"><a href="#Xcode8禁止控制台打印干扰信息" class="headerlink" title="Xcode8禁止控制台打印干扰信息"></a>Xcode8禁止控制台打印干扰信息</h5><p><strong>Product》Scheme》Edit Scheme…</strong> ，Run标签栏中选择Arguments选项卡，在Environments Variables 中添加字典<code>OS_ACTIVITY_MODE=disable</code></p>
<ul>
<li>Name:OS_ACTIVITY_MODE</li>
<li>Value:disable</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="http://blog.csdn.net/u012681458/article/details/51865435" target="_blank" rel="external">升级Xcode8后的相机crash问题-IOS10权限问题</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天很多苹果开发的小伙伴迫不及待的升级了Xcode8，可是升级完成之后项目中也遇到了很多小问题，下面就一一列举相关问题。&lt;/p&gt;
&lt;p&gt;如果你的项目中访问了相机，相册，麦克风等设备，你需要在info.plist文件里做先关配置，如果没有配置相关信息，程序会直接退出。&lt;/p&gt;
&lt;h5 id=&quot;访问相机&quot;&gt;&lt;a href=&quot;#访问相机&quot; class=&quot;headerlink&quot; title=&quot;访问相机&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html&quot;&gt;访问相机&lt;/a&gt;&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;Important: To protect user privacy, an iOS app linked on or after iOS 10.0, and which accesses the device’s camera, must statically declare the intent to do so. Include the NSCameraUsageDescription key in your app’s Info.plist file and provide a purpose string for this key. If your app attempts to access the device’s camera without a corresponding purpose string, your app exits.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据苹果的描述信息，你需要在info.plist文件里面做相关配置。&lt;/p&gt;
&lt;p&gt;```objc&lt;/p&gt;
&lt;p&gt;&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;&lt;/p&gt;
&lt;p&gt;&lt;string&gt;允许此权限才能使用相机&lt;/string&gt;&lt;br&gt;```&lt;/p&gt;
&lt;h5 id=&quot;访问相册&quot;&gt;&lt;a href=&quot;#访问相册&quot; class=&quot;headerlink&quot; title=&quot;访问相册&quot;&gt;&lt;/a&gt;访问相册&lt;/h5&gt;&lt;p&gt;此处相关链接可以参考访问相机，以下连接相同。&lt;/p&gt;
&lt;p&gt;```objc&lt;/p&gt;
&lt;p&gt;&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;&lt;/p&gt;
&lt;p&gt;&lt;string&gt;允许此权限才能访问相册&lt;/string&gt;&lt;br&gt;```&lt;/p&gt;
&lt;h5 id=&quot;访问麦克风&quot;&gt;&lt;a href=&quot;#访问麦克风&quot; class=&quot;headerlink&quot; title=&quot;访问麦克风&quot;&gt;&lt;/a&gt;访问麦克风&lt;/h5&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>关于适配的总结</title>
    <link href="http://sz8023.github.io/2016/05/14/iOS-20160928%E5%85%B3%E4%BA%8E%E9%80%82%E9%85%8D%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://sz8023.github.io/2016/05/14/iOS-20160928关于适配的总结/</id>
    <published>2016-05-14T06:49:15.000Z</published>
    <updated>2016-09-30T07:31:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中，比较常用的适配模式就是xib，storyboard和纯代码的方式。而纯代码方式我使用比较多的是第三方库<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">Masonry</a>。但是对于这些概念一直比较模糊，比如发展历史，使用区别，使用频率，在什么时候选用什么样的布局方式等等。</p>
<table>
<thead>
<tr>
<th style="text-align:center">设备</th>
<th style="text-align:center">适配技术</th>
<th style="text-align:center">优缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">iPhone4/4s</td>
<td style="text-align:center">通过frame计算</td>
<td style="text-align:center">设备比较单一，计算量比较小</td>
</tr>
<tr>
<td style="text-align:center">iPad</td>
<td style="text-align:center">AutoResizing</td>
<td style="text-align:center">只可以实现父子控件之间的约束</td>
</tr>
<tr>
<td style="text-align:center">iPhone5/5s</td>
<td style="text-align:center">AutoLayout</td>
<td style="text-align:center">既可以实现父子控件约束，又可以实现同级控件之间的约束</td>
</tr>
<tr>
<td style="text-align:center">iPhone6/6s</td>
<td style="text-align:center">SizeClass</td>
<td style="text-align:center">可以给不同设备设置不同的约束，AutoLayout可以给不同设备设置同一                              套约束</td>
</tr>
</tbody>
</table>
<p>通常这几种技术当中，AutoResizing的工作完全可以由AutoLayout来代替，所以开发中几乎不再考虑。对于iPhone的不同设备采用同一套布局方式是很多公司都会采用的方式，如果再去考虑iPad的话开发工作是比较繁琐的，所以AutoLayout的使用频率是最高的。倘若真的要考虑同时适配iPhone和iPad的话，那么肯定要采用不同的布局方式，因为iPad的屏幕宽高比跟iPhone相差还是很大的，这个时候SizeClass就是你的最佳选择。</p>
<p>这个时候我觉得还需要把计算frame和AutoLayout拿出来说一下，毕竟很多人可能会像我一样在日常的Demo中会通过计算frame的方式最快的查看想要的结果。</p>
<ul>
<li>通过frame计算的方式实现方式比较简单，远比NSLayoutConstraints语法简单</li>
<li>相对布局frame可以通过CGRectGetMaxY或者CGRectGetMaxX等来实现相对布局。</li>
<li>重点是：通过frame和AutoLayout其他方式上的区别还在探索当中……</li>
</ul>
<h4 id="关于适配"><a href="#关于适配" class="headerlink" title="关于适配"></a>关于适配</h4><p>跟设备有关的会涉及到设备和系统，如今iPhone有很多不同设备，比如iPhone5,iPhone6等；同一个种设备又可能存在不同的系统，比如iOS9.0，iOS10.0等。</p>
<p>如何区分不同设备，开发中喜欢使用下面的方式，由于iPhone7跟iPhone6的尺寸没有发生变化，所以这边值需要对不同的设备尺寸有个区分就可以了。</p>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#define IS_IPHONE4 (([[UIScreen mainScreen] bounds].size.height == 480) ? YES : NO)</span></div><div class="line"><span class="meta">#define IS_IPHONE5 (([[UIScreen mainScreen] bounds].size.height == 568) ? YES : NO)</span></div><div class="line"><span class="meta">#define IS_IPhone6 (([[UIScreen mainScreen] bounds].size.height == 667) ? YES : NO)</span></div><div class="line"><span class="meta">#define IOS_IPhone6plusS (([[UIScreen mainScreen] bounds].size.height = 736) ? YES : NO)</span></div></pre></td></tr></table></figure>
<p>那么在什么地方经常会用到这些宏呢？</p>
<ul>
<li>配置启动图片</li>
<li>设置UICollectionView中cell之间的spacing</li>
<li>……</li>
</ul>
<p>设备系统的判断，也可以通过宏定义的方式来实现，下面的代码可用于系统的判断</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#define IS_OS_8_OR_LATER    ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0)</span></div><div class="line"><span class="meta">#define IS_OS_9_OR_LATER    ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 9.0)</span></div><div class="line"><span class="meta">#define IS_OS_10_OR_LATER    ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 10.0)</span></div></pre></td></tr></table></figure>
<p>或者通过这样判断也可以达到相同的效果。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//判断系统版本</span></div><div class="line"><span class="meta">#define SYSTEM_VERSION_EQUAL_TO(v)                  ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedSame)</span></div><div class="line"><span class="meta">#define SYSTEM_VERSION_GREATER_THAN(v)              ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedDescending)</span></div><div class="line"><span class="meta">#define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v)  ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)</span></div><div class="line"><span class="meta">#define SYSTEM_VERSION_LESS_THAN(v)                 ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)</span></div><div class="line"><span class="meta">#define SYSTEM_VERSION_LESS_THAN_OR_EQUAL_TO(v)     ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedDescending)</span></div></pre></td></tr></table></figure>
<p>同样，什么地方需要用来判断系统？有些功能低版本的没有！</p>
<ul>
<li>地图需要请求权限才可以，并且需要配合info.plist，这个在iOS8.0以后</li>
<li>字体设置，比如“PingFangSC-Regular”字体iOS9.0之后才可以使用</li>
<li>3DTouch功能只有iOS9.0之后才有</li>
<li>……</li>
</ul>
<h4 id="关于Masonry"><a href="#关于Masonry" class="headerlink" title="关于Masonry"></a>关于Masonry</h4><p>开发中最长使用的是Masonry，关于这个可以参考<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">Masonry官网</a></p>
<p>关于使用方式可以参考官方的Demo。官方的Demo中已经给出了很好例子说明。</p>
<table>
<thead>
<tr>
<th>Basic</th>
<th>基础用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Update Constraints</td>
<td>更新约束</td>
</tr>
<tr>
<td>Remark Constraints</td>
<td>标记约束</td>
</tr>
<tr>
<td>Using Constraints</td>
<td>使用约束</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常开发中，比较常用的适配模式就是xib，storyboard和纯代码的方式。而纯代码方式我使用比较多的是第三方库&lt;a href=&quot;https://github.com/SnapKit/Masonry&quot;&gt;Masonry&lt;/a&gt;。但是对于这些概念一直比较模糊，比如发展历史，使用区别，使用频率，在什么时候选用什么样的布局方式等等。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;设备&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;适配技术&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;优缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;iPhone4/4s&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;通过frame计算&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;设备比较单一，计算量比较小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;iPad&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;AutoResizing&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;只可以实现父子控件之间的约束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;iPhone5/5s&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;AutoLayout&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;既可以实现父子控件约束，又可以实现同级控件之间的约束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;iPhone6/6s&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;SizeClass&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;可以给不同设备设置不同的约束，AutoLayout可以给不同设备设置同一                              套约束&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;通常这几种技术当中，AutoResizing的工作完全可以由AutoLayout来代替，所以开发中几乎不再考虑。对于iPhone的不同设备采用同一套布局方式是很多公司都会采用的方式，如果再去考虑iPad的话开发工作是比较繁琐的，所以AutoLayout的使用频率是最高的。倘若真的要考虑同时适配iPhone和iPad的话，那么肯定要采用不同的布局方式，因为iPad的屏幕宽高比跟iPhone相差还是很大的，这个时候SizeClass就是你的最佳选择。&lt;/p&gt;
&lt;p&gt;这个时候我觉得还需要把计算frame和AutoLayout拿出来说一下，毕竟很多人可能会像我一样在日常的Demo中会通过计算frame的方式最快的查看想要的结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过frame计算的方式实现方式比较简单，远比NSLayoutConstraints语法简单&lt;/li&gt;
&lt;li&gt;相对布局frame可以通过CGRectGetMaxY或者CGRectGetMaxX等来实现相对布局。&lt;/li&gt;
&lt;li&gt;重点是：通过frame和AutoLayout其他方式上的区别还在探索当中……&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;关于适配&quot;&gt;&lt;a href=&quot;#关于适配&quot; class=&quot;headerlink&quot; title=&quot;关于适配&quot;&gt;&lt;/a&gt;关于适配&lt;/h4&gt;&lt;p&gt;跟设备有关的会涉及到设备和系统，如今iPhone有很多不同设备，比如iPhone5,iPhone6等；同一个种设备又可能存在不同的系统，比如iOS9.0，iOS10.0等。&lt;/p&gt;
&lt;p&gt;如何区分不同设备，开发中喜欢使用下面的方式，由于iPhone7跟iPhone6的尺寸没有发生变化，所以这边值需要对不同的设备尺寸有个区分就可以了。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>CornerStone使用小技巧</title>
    <link href="http://sz8023.github.io/2016/04/23/iOS-20160923CornerStone%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://sz8023.github.io/2016/04/23/iOS-20160923CornerStone使用小技巧/</id>
    <published>2016-04-23T07:05:11.000Z</published>
    <updated>2016-10-12T15:46:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用CornerStone工具的时候有一些常用的小技巧，当然这些小技巧可能很多人都知道，但是对于刚刚接触的小伙伴来说可能就不一样了。所以，记录了一下给自己也给大家做一个参考。</p>
<h3 id="关于忽略文件的问题"><a href="#关于忽略文件的问题" class="headerlink" title="关于忽略文件的问题"></a>关于忽略文件的问题</h3><p>在项目初始化创建的时候可能会需要处理<code>.xcuserdatad</code>文件的问题，这个问题我也在网上搜索了一些答案，但是总感觉过程太过繁琐。</p>
<p>前几天在跟朋友峰哥讨论“如何提交.a文件到SVN”的时候，在峰哥指导下，知道了通过如何配置CornerStone来解决这个<code>.a</code>文件的提交问题。同样的，我觉得对于<code>.xcuserdatad</code>文件也可以用同样的问题来解决。</p>
<p>通过打开CornerStone的<strong>CornerStone</strong>》<strong>Preferences..</strong>》，然后点击<strong>Subversion</strong>选项卡，再选择<strong>General</strong>，可以发现有个<strong>Global Ignores</strong>。</p>
<p><img src="../images/CornerStone.png" alt="CornerStone"></p>
<p>如果你不想使用系统默认的忽略文件，那么就不要勾选<strong>User default global ignores</strong>。然后在这边你可以去掉或者添加你想要忽略的文件。</p>
<h3 id="对于Xcode如何处理"><a href="#对于Xcode如何处理" class="headerlink" title="对于Xcode如何处理"></a>对于Xcode如何处理</h3><p>之前没有使用CornerStone的时候，一直使用的是Xcode自带的SVN版本管理，对于<code>.a</code>文件同样会要相同的问题，当时的解决思路是通过命令的方式在终端将<code>.a</code>文件提交到SVN。但是可不可以通过配置的方式解决这个问题，还有待进一步研究。</p>
<a id="more"></a>
<h3 id="其他的一些细节处理"><a href="#其他的一些细节处理" class="headerlink" title="其他的一些细节处理"></a>其他的一些细节处理</h3><ul>
<li>在WORKING COPY对应的工作控件创建文件夹或者文件，CornerStone可以自动识别，并且会在客户端有一个<code>?</code>显示，告诉程序员有一个文件或者文件夹没有被添加到本地的SVN，如果你没有选择添加，那么在提交的时候（及当commit的时候），会有提示，告诉你有文件没有添加到本地的SVN，这个时候你可以选择<code>Add to Working Copy</code>将文件夹或者文件添加到本地的SVN。</li>
</ul>
<p><img src="../images/CornerStone_commit.png" width="640" alt="CornerStone_commit"></p>
<ul>
<li>如果你是在Xcode中通过New Group创建的文件夹，那么这个文件夹只是虚拟的文件夹，之后通过右键Finder创建的文件夹才是实实在在的文件夹，然后你可以将这个文件Import到项目中，或者拖动到项目中，这个时候CornerStone依然可以会提示你文件或者文件夹是否添加到本地的SVN当中。可以通过底部的工具栏<code>Add</code>将文件添加到本地的SVN中。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用CornerStone工具的时候有一些常用的小技巧，当然这些小技巧可能很多人都知道，但是对于刚刚接触的小伙伴来说可能就不一样了。所以，记录了一下给自己也给大家做一个参考。&lt;/p&gt;
&lt;h3 id=&quot;关于忽略文件的问题&quot;&gt;&lt;a href=&quot;#关于忽略文件的问题&quot; class=&quot;headerlink&quot; title=&quot;关于忽略文件的问题&quot;&gt;&lt;/a&gt;关于忽略文件的问题&lt;/h3&gt;&lt;p&gt;在项目初始化创建的时候可能会需要处理&lt;code&gt;.xcuserdatad&lt;/code&gt;文件的问题，这个问题我也在网上搜索了一些答案，但是总感觉过程太过繁琐。&lt;/p&gt;
&lt;p&gt;前几天在跟朋友峰哥讨论“如何提交.a文件到SVN”的时候，在峰哥指导下，知道了通过如何配置CornerStone来解决这个&lt;code&gt;.a&lt;/code&gt;文件的提交问题。同样的，我觉得对于&lt;code&gt;.xcuserdatad&lt;/code&gt;文件也可以用同样的问题来解决。&lt;/p&gt;
&lt;p&gt;通过打开CornerStone的&lt;strong&gt;CornerStone&lt;/strong&gt;》&lt;strong&gt;Preferences..&lt;/strong&gt;》，然后点击&lt;strong&gt;Subversion&lt;/strong&gt;选项卡，再选择&lt;strong&gt;General&lt;/strong&gt;，可以发现有个&lt;strong&gt;Global Ignores&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/CornerStone.png&quot; alt=&quot;CornerStone&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你不想使用系统默认的忽略文件，那么就不要勾选&lt;strong&gt;User default global ignores&lt;/strong&gt;。然后在这边你可以去掉或者添加你想要忽略的文件。&lt;/p&gt;
&lt;h3 id=&quot;对于Xcode如何处理&quot;&gt;&lt;a href=&quot;#对于Xcode如何处理&quot; class=&quot;headerlink&quot; title=&quot;对于Xcode如何处理&quot;&gt;&lt;/a&gt;对于Xcode如何处理&lt;/h3&gt;&lt;p&gt;之前没有使用CornerStone的时候，一直使用的是Xcode自带的SVN版本管理，对于&lt;code&gt;.a&lt;/code&gt;文件同样会要相同的问题，当时的解决思路是通过命令的方式在终端将&lt;code&gt;.a&lt;/code&gt;文件提交到SVN。但是可不可以通过配置的方式解决这个问题，还有待进一步研究。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>开发杂烩</title>
    <link href="http://sz8023.github.io/2016/03/16/iOS-%E5%BC%80%E5%8F%91%E6%9D%82%E7%83%A9/"/>
    <id>http://sz8023.github.io/2016/03/16/iOS-开发杂烩/</id>
    <published>2016-03-15T23:53:10.000Z</published>
    <updated>2016-09-22T08:26:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录一些开发中常用的技巧。比如常用的常量文件，宏定义文件，什么时候创建分类，什么时候使用继承，什么时候使用代理封装第三方库（哪些第三方库需要封装，如何封装）等等。</p>
<h3 id="关于常量"><a href="#关于常量" class="headerlink" title="关于常量"></a>关于常量</h3><p>很显然不变的量就是常量，比较常用的地方就是整形，浮点型，字符串等。这个时候不建议使用#define来定义。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> weight = <span class="number">70</span>;<span class="comment">// 定义一个整形常量</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> height = <span class="number">166.0</span>;<span class="comment">// 定义一个浮点型常量</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> <span class="keyword">const</span> *city = <span class="string">@"上海"</span>;<span class="comment">// 定义一个常量字符串</span></div></pre></td></tr></table></figure>
<h3 id="关于宏定义"><a href="#关于宏定义" class="headerlink" title="关于宏定义"></a>关于宏定义</h3><p>宏定义是预处理命令，及在预编译阶段进行字符替换，在使用的时候要注意“边缘效应”。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#define kScreen_bounds [[UIScreen mainScreen] bounds]</span></div><div class="line"><span class="meta">#define kScreen_Height [[UIScreen mainScreen] bounds].size.height</span></div><div class="line"><span class="meta">#define kScreen_Width [[UIScreen mainScreen] bounds].size.width</span></div><div class="line"><span class="meta">#define IS_IPHONE4 (([[UIScreen mainScreen] bounds].size.height == 480) ? YES : NO)</span></div><div class="line"><span class="meta">#define IS_IPHONE5 (([[UIScreen mainScreen] bounds].size.height == 568) ? YES : NO)</span></div><div class="line"><span class="meta">#define IS_IPhone6 (([[UIScreen mainScreen] bounds].size.height == 667) ? YES : NO)</span></div><div class="line"><span class="meta">#define IOS_IPhone6plusS (([[UIScreen mainScreen] bounds].size.height = 736) ? YES : NO)</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>所谓的边缘效应是指：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#define sum(a) a + 5</span></div><div class="line"><span class="built_in">CGFloat</span> minus = sum(<span class="number">5</span>) * <span class="number">4</span>;</div><div class="line"><span class="comment">// 由于宏定义只是简单的替换，所以minus的结果不是40，而是 5 + 5 * 4 = 25;这就是边缘效应。</span></div><div class="line"><span class="comment">// 正确使用方式 #define sum(a) (a + 5)</span></div></pre></td></tr></table></figure>
<h3 id="什么时候创建分类"><a href="#什么时候创建分类" class="headerlink" title="什么时候创建分类"></a>什么时候创建分类</h3><p>如果想要给系统的类增添新的方法可以使用分类，比如给UIButton，UIImageView，UIBarButtonItem创建分类等。分类的方法是向下有效的，及会影响到该类的所有子类。</p>
<ul>
<li>分类只能用于添加成员方法，不能用于添加成员变量。</li>
<li>分类增加的方法，如果与原来的类方法同名，会覆盖原来的方法，因为Category的优先级更高</li>
</ul>
<h3 id="什么时候使用继承"><a href="#什么时候使用继承" class="headerlink" title="什么时候使用继承"></a>什么时候使用继承</h3><p>假如目标了你有许多子类，我们希望扩展这个类，又不希望影响到原有的代码，继承后比较好。如果仅仅是扩展方法，分类更好（不需要涉及到原先的代码）</p>
<ul>
<li>可以添加成员变量，也可以添加成员方法。</li>
<li>继承增加的方法不会成为基类的一部分。</li>
</ul>
<h3 id="什么时候封装第三方库"><a href="#什么时候封装第三方库" class="headerlink" title="什么时候封装第三方库"></a>什么时候封装第三方库</h3><p>使用第三方库的好处：</p>
<ul>
<li>缩短开发周期</li>
<li>成熟的第三方库很多人一起维护，Bug很少</li>
<li>有些功能自己没有能力实现</li>
</ul>
<p>有哪些第三方库需要封装？</p>
<ul>
<li>网络AFNetworking</li>
<li>数据库fmdb</li>
<li>……</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="http://blog.csdn.net/fiona_yang123456/article/details/41044979" target="_blank" rel="external">iOS中继承与分类</a></li>
<li><a href="https://my.oschina.net/jack088/blog/605813" target="_blank" rel="external">iOS分类、扩展和继承的区别</a></li>
<li><a href="http://www.jianshu.com/p/97f0684a7dd8" target="_blank" rel="external">封装第三方库的必要性</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录一些开发中常用的技巧。比如常用的常量文件，宏定义文件，什么时候创建分类，什么时候使用继承，什么时候使用代理封装第三方库（哪些第三方库需要封装，如何封装）等等。&lt;/p&gt;
&lt;h3 id=&quot;关于常量&quot;&gt;&lt;a href=&quot;#关于常量&quot; class=&quot;headerlink&quot; title=&quot;关于常量&quot;&gt;&lt;/a&gt;关于常量&lt;/h3&gt;&lt;p&gt;很显然不变的量就是常量，比较常用的地方就是整形，浮点型，字符串等。这个时候不建议使用#define来定义。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; weight = &lt;span class=&quot;number&quot;&gt;70&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;// 定义一个整形常量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; height = &lt;span class=&quot;number&quot;&gt;166.0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;// 定义一个浮点型常量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; *city = &lt;span class=&quot;string&quot;&gt;@&quot;上海&quot;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;// 定义一个常量字符串&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;关于宏定义&quot;&gt;&lt;a href=&quot;#关于宏定义&quot; class=&quot;headerlink&quot; title=&quot;关于宏定义&quot;&gt;&lt;/a&gt;关于宏定义&lt;/h3&gt;&lt;p&gt;宏定义是预处理命令，及在预编译阶段进行字符替换，在使用的时候要注意“边缘效应”。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define kScreen_bounds [[UIScreen mainScreen] bounds]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define kScreen_Height [[UIScreen mainScreen] bounds].size.height&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define kScreen_Width [[UIScreen mainScreen] bounds].size.width&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define IS_IPHONE4 (([[UIScreen mainScreen] bounds].size.height == 480) ? YES : NO)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define IS_IPHONE5 (([[UIScreen mainScreen] bounds].size.height == 568) ? YES : NO)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define IS_IPhone6 (([[UIScreen mainScreen] bounds].size.height == 667) ? YES : NO)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define IOS_IPhone6plusS (([[UIScreen mainScreen] bounds].size.height = 736) ? YES : NO)&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>控制器中视图的布局</title>
    <link href="http://sz8023.github.io/2016/03/11/iOS-20160916%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E8%A7%86%E5%9B%BE%E7%9A%84%E5%B8%83%E5%B1%80/"/>
    <id>http://sz8023.github.io/2016/03/11/iOS-20160916控制器中视图的布局/</id>
    <published>2016-03-11T06:35:28.000Z</published>
    <updated>2016-09-22T05:35:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>控制器中除了默认的根视图不需要我们适配之外，根视图的所有子视图几乎都需要我们进行适配。如果是纯代码的话你可以在<code>- (void)viewDidLoad</code>中进行适配(相对父视图进行布局)。但是如果你想要跟新rootView的子视图，你需要在<code>viewWillLayoutSubviews</code>或<code>viewDidLayoutSubviews</code>方法中进行更新。这2个方法的主要区别是前者根视图适配完成，但是子视图适配并没有确定（需要根据设备来确定），而后者子视图的适配已经完成。如果你参考非根视图进行布局更新，建议在后者方法中进行布局更新。如果参考根视图则任意选择。</p>
<p>当然你也可以在其他方法中通过调动[view setNeedsLayout]和[view layoutIfNeeded]给控件进行提前布局。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>控件szView和szLBL分别是根视图view的子视图。ViewController采用storyboard的方式进行编码。</p>
<pre><code><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *szView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *szLBL;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)awakeFromNib &#123;</div><div class="line">    [<span class="keyword">super</span> awakeFromNib];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.view.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szView.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szLBL.frame));</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.view.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szView.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szLBL.frame));</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    [<span class="keyword">super</span> viewWillAppear: animated];</div><div class="line"><span class="comment">//    [self.view layoutIfNeeded];</span></div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.view.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szView.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szLBL.frame));</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewWillLayoutSubviews &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.view.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szView.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szLBL.frame));</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLayoutSubviews &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.view.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szView.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szLBL.frame));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><a id="more"></a>
<p>打印结果如下：</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"> <span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.735</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewDidLoad] *****	 &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">414</span>, <span class="number">736</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.736</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewDidLoad] *****	 &#123;&#123;<span class="number">30</span>, <span class="number">50</span>&#125;, &#123;<span class="number">315</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.736</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewDidLoad] *****	 &#123;&#123;<span class="number">100</span>, <span class="number">190</span>&#125;, &#123;<span class="number">175</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.736</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController awakeFromNib] *****	 &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">414</span>, <span class="number">736</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.736</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController awakeFromNib] *****	 &#123;&#123;<span class="number">30</span>, <span class="number">50</span>&#125;, &#123;<span class="number">315</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.737</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController awakeFromNib] *****	 &#123;&#123;<span class="number">100</span>, <span class="number">190</span>&#125;, &#123;<span class="number">175</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.743</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewWillAppear:] *****	 &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">414</span>, <span class="number">736</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.743</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewWillAppear:] *****	 &#123;&#123;<span class="number">30</span>, <span class="number">50</span>&#125;, &#123;<span class="number">315</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.743</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewWillAppear:] *****	 &#123;&#123;<span class="number">100</span>, <span class="number">190</span>&#125;, &#123;<span class="number">175</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.750</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewWillLayoutSubviews] *****	 &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">414</span>, <span class="number">736</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.750</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewWillLayoutSubviews] *****	 &#123;&#123;<span class="number">30</span>, <span class="number">50</span>&#125;, &#123;<span class="number">315</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.754</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewWillLayoutSubviews] *****	 &#123;&#123;<span class="number">100</span>, <span class="number">190</span>&#125;, &#123;<span class="number">175</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.754</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewDidLayoutSubviews] *****	 &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">414</span>, <span class="number">736</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.754</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewDidLayoutSubviews] *****	 &#123;&#123;<span class="number">30</span>, <span class="number">50</span>&#125;, &#123;<span class="number">354</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.755</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewDidLayoutSubviews] *****	 &#123;&#123;<span class="number">100</span>, <span class="number">190</span>&#125;, &#123;<span class="number">214</span>, <span class="number">100</span>&#125;&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;控制器中除了默认的根视图不需要我们适配之外，根视图的所有子视图几乎都需要我们进行适配。如果是纯代码的话你可以在&lt;code&gt;- (void)viewDidLoad&lt;/code&gt;中进行适配(相对父视图进行布局)。但是如果你想要跟新rootView的子视图，你需要在&lt;code&gt;viewWillLayoutSubviews&lt;/code&gt;或&lt;code&gt;viewDidLayoutSubviews&lt;/code&gt;方法中进行更新。这2个方法的主要区别是前者根视图适配完成，但是子视图适配并没有确定（需要根据设备来确定），而后者子视图的适配已经完成。如果你参考非根视图进行布局更新，建议在后者方法中进行布局更新。如果参考根视图则任意选择。&lt;/p&gt;
&lt;p&gt;当然你也可以在其他方法中通过调动[view setNeedsLayout]和[view layoutIfNeeded]给控件进行提前布局。&lt;/p&gt;
&lt;h3 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h3&gt;&lt;p&gt;控件szView和szLBL分别是根视图view的子视图。ViewController采用storyboard的方式进行编码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&quot;ViewController.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewController&lt;/span&gt; ()&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;IBOutlet&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *szView;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;IBOutlet&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;UILabel&lt;/span&gt; *szLBL;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewController&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)awakeFromNib &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; awakeFromNib];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szView.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szLBL.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLoad &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewDidLoad];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szView.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szLBL.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewWillAppear:(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)animated &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewWillAppear: animated];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//    [self.view layoutIfNeeded];&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szView.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szLBL.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewWillLayoutSubviews &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szView.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szLBL.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLayoutSubviews &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szView.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szLBL.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>代理和通知</title>
    <link href="http://sz8023.github.io/2016/02/10/iOS-%E4%BB%A3%E7%90%86%E5%92%8C%E9%80%9A%E7%9F%A5/"/>
    <id>http://sz8023.github.io/2016/02/10/iOS-代理和通知/</id>
    <published>2016-02-09T23:46:27.000Z</published>
    <updated>2016-09-22T05:43:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发中离不开代理（或Block）和通知。到底什么时候使用代理，什么时候使用通知呢？首先我们从概念入手。<br><!--此处概念来自苹果官网或者stackoverflow--></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>协议Protocol：</strong>接口是一堆方法的声明，但是没有实现。协议也是一堆方法的声明没有实现，在此基础上增加了选择实现和必须实现方法的选择。</p>
<p><strong>代理Delegate：</strong>传入的对象代替了当前类完成了某个功能，成为代理模式。使用场景，对象A发生了某些事情想要告诉对象B的时候或者对象B想要监听对象A发生了什么事情，都可以让对象B成为对象A的代理。</p>
<p><strong>通知Notification：</strong> 通知可以实现多个对象之间传递消息，不论对象之间的层次关系多么复杂。通知是线程同步的。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>通知和代理都可以实现对象和对象之间的传值，不同之处在与代理实现的是逻辑关系简单，视图层次不复杂的一对一传值，而通知用的比较多的场合是逻辑关系较为复杂，视图层次比较深的一对多传值。</p>
<h4 id="什么时候使用代理"><a href="#什么时候使用代理" class="headerlink" title="什么时候使用代理"></a>什么时候使用代理</h4><ul>
<li>自定义控件的时候，如果想要将控件的点击事件传递出去，需要使用代理。</li>
<li>控制器传值，如果想要将目标控制器中的数据传递给源控制器可以使用代理。</li>
<li>网络部分也可以通过代理的方式来处理响应结果。</li>
</ul>
<p>可以使用代理的地方都可以使用block来代替，而且使用方式更简单！</p>
<a id="more"></a>
<h4 id="什么时候使用通知"><a href="#什么时候使用通知" class="headerlink" title="什么时候使用通知"></a>什么时候使用通知</h4><p>如果是自定义的view，那么可以在init方法中添加通知，如果是控制器，可以在viewDidLoad方法中添加通知，在dealloc方法中移除通知，移除通知的时候，一定要使用<code>removeObserver: name: object:</code>带有name的方法，这样可以避免移除该对象的其他通知（可能是系统自带的通知）。</p>
<ul>
<li>如果自定义控件存在多层嵌套，可以使用通知来传递事件</li>
<li>如果一个控制器想要通知其他控制器刷新界面的时候可以使用通知</li>
</ul>
<h3 id="开发中哪些地方会用到"><a href="#开发中哪些地方会用到" class="headerlink" title="开发中哪些地方会用到"></a>开发中哪些地方会用到</h3><p>从顺传和逆传的角度考虑</p>
<ul>
<li>自定义控件</li>
<li>控制器之间传值</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发中离不开代理（或Block）和通知。到底什么时候使用代理，什么时候使用通知呢？首先我们从概念入手。&lt;br&gt;&lt;!--此处概念来自苹果官网或者stackoverflow--&gt;&lt;/p&gt;
&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;协议Protocol：&lt;/strong&gt;接口是一堆方法的声明，但是没有实现。协议也是一堆方法的声明没有实现，在此基础上增加了选择实现和必须实现方法的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理Delegate：&lt;/strong&gt;传入的对象代替了当前类完成了某个功能，成为代理模式。使用场景，对象A发生了某些事情想要告诉对象B的时候或者对象B想要监听对象A发生了什么事情，都可以让对象B成为对象A的代理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通知Notification：&lt;/strong&gt; 通知可以实现多个对象之间传递消息，不论对象之间的层次关系多么复杂。通知是线程同步的。&lt;/p&gt;
&lt;h3 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h3&gt;&lt;p&gt;通知和代理都可以实现对象和对象之间的传值，不同之处在与代理实现的是逻辑关系简单，视图层次不复杂的一对一传值，而通知用的比较多的场合是逻辑关系较为复杂，视图层次比较深的一对多传值。&lt;/p&gt;
&lt;h4 id=&quot;什么时候使用代理&quot;&gt;&lt;a href=&quot;#什么时候使用代理&quot; class=&quot;headerlink&quot; title=&quot;什么时候使用代理&quot;&gt;&lt;/a&gt;什么时候使用代理&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;自定义控件的时候，如果想要将控件的点击事件传递出去，需要使用代理。&lt;/li&gt;
&lt;li&gt;控制器传值，如果想要将目标控制器中的数据传递给源控制器可以使用代理。&lt;/li&gt;
&lt;li&gt;网络部分也可以通过代理的方式来处理响应结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用代理的地方都可以使用block来代替，而且使用方式更简单！&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义控件</title>
    <link href="http://sz8023.github.io/2016/01/14/iOS-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    <id>http://sz8023.github.io/2016/01/14/iOS-自定义控件/</id>
    <published>2016-01-14T09:04:37.000Z</published>
    <updated>2016-09-19T08:03:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS的开发中，系统自带的控件有时候根本无法满足开发的需要，这个时候你就需要自定义控件。关于自定义控件我是这么理解的。</p>
<ul>
<li>如果可以修改原生控件，那么就去修改原生的控件，毕竟系统的控件自带了很多高性能的功能给我们使用。比如修改原生控件的布局。</li>
<li>可以在原生控件的基础上进行再造轮子，比如添加一些控件，这样就可以保留原生控件的一些性能。</li>
<li>完全自定义控件，这个时候你可能需要考虑2个问题，这个控件是否支持Xib或storyboard，还是仅仅支持代码的格式。</li>
</ul>
<p>基于以上的几种情况，大致进行了一些总结。</p>
<h3 id="修改原生控件的布局"><a href="#修改原生控件的布局" class="headerlink" title="修改原生控件的布局"></a>修改原生控件的布局</h3><p>修改原生控件的布局情况在UIButton这个控件当中尤为明显。比如说UIButton的图片默认是居左显示的，那么有时候可能需要让图片居上，居下或者居右显示。这个时候你就可以选择修改原生控件的布局来结局这个问题。由于<code>layoutSubviews</code>在以下几种情况下回自动调用。</p>
<ol>
<li>init初始化不会出发layoutSubviews。但是用initWithFrame进行初始化的时候，如果rect的值不为CGRectZero时，也会触发。</li>
<li>addSubview会触发layoutSubviews</li>
<li>设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化</li>
<li>滚动一个UIScrollView会触发layoutSubviews</li>
<li>旋转UIScreen会触发父UIView的layoutSubviews事件</li>
<li>改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件</li>
</ol>
<p>以上都是系统自动刷新，那么我们如何进行手动刷新呢？</p>
<ol>
<li>setNeedsLayout：标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但是layoutSubviews一定会被调用</li>
<li>layoutIfNeeded：如果，有需要刷新的标记，立即调用layoutSubviews进行重新布局(如果没有标记，不会调用layoutSubviews)</li>
</ol>
<a id="more"></a>
<p>如果要立即刷新，需要先调用[view setNeedsLayout]，把标记设置为需要布局，然后马上调用[view layoutIfNeeded]，实现布局。</p>
<p>在视图第一次显示之前，标记总是“需要刷新”的，可以直接调用[view layoutIfNeeded]。</p>
<p>所以如果不需要更新布局，那么你只需要在init方法中给添加的子控件布局就可以了。</p>
<pre><code><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</div><div class="line">       <span class="comment">// 在此处对子控件进行布局</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>你可是在<code>- (void)layoutSubviews</code>中对子控件更新布局。</p>
<h3 id="原生基础上再造轮子"><a href="#原生基础上再造轮子" class="headerlink" title="原生基础上再造轮子"></a>原生基础上再造轮子</h3><p>依然是同样的一个问题，如果是图片需要显示在顶部。如果你不是修改UIButton中title和image的布局，那么你可以给UIImageView进行重新改造。</p>
<pre><code><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"SZImageView.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SZImageView</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)awakeFromNib &#123;</div><div class="line">    [<span class="keyword">super</span> awakeFromNib];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> addCustomView];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</div><div class="line">        [<span class="keyword">self</span> addCustomView];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addCustomView &#123;</div><div class="line">    <span class="built_in">UILabel</span> *imgLBL = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.bounds), <span class="built_in">CGRectGetHeight</span>(<span class="keyword">self</span>.bounds)/<span class="number">4.0</span>)];</div><div class="line">    [<span class="keyword">self</span> addSubview:imgLBL];</div><div class="line">    <span class="keyword">self</span>.imgLBL = imgLBL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>不过这个时候如果你需要给这个控件添加事件的话，可能还需要再添加手势了，此处不做进一步讨论。</p>
<h3 id="完全自定义控件"><a href="#完全自定义控件" class="headerlink" title="完全自定义控件"></a>完全自定义控件</h3><p>同一个问题不同的解决思路，你也可以通过继承UIView来自定义一个这样的控件。你需要在这个UIView上绘制Image，绘制Text。最简单的方式就是在UIView里面添加一个UIImageView和UILabel，通过修改它们的布局来达到我们想要的效果。</p>
<p>……</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在<code>- (void)layoutSubviews</code>方法中，你需要先调用父类的方法，然后再开始自己的布局。当然这个布局是相对于当前视图的布局，因为当前receiver的frame一定是确定的，而receiver的其他子控件可能由于设备的大小问题，而存在适配问题，不过你也可以再进行子控件的相对布局之前。调用子控件的<code>layoutIfNeeded</code>方法来确定他的frame。</p>
<p>对于控制器中的视图布局，在后期会做一点介绍，感觉文章质量有待进一步提升~_~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS的开发中，系统自带的控件有时候根本无法满足开发的需要，这个时候你就需要自定义控件。关于自定义控件我是这么理解的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果可以修改原生控件，那么就去修改原生的控件，毕竟系统的控件自带了很多高性能的功能给我们使用。比如修改原生控件的布局。&lt;/li&gt;
&lt;li&gt;可以在原生控件的基础上进行再造轮子，比如添加一些控件，这样就可以保留原生控件的一些性能。&lt;/li&gt;
&lt;li&gt;完全自定义控件，这个时候你可能需要考虑2个问题，这个控件是否支持Xib或storyboard，还是仅仅支持代码的格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于以上的几种情况，大致进行了一些总结。&lt;/p&gt;
&lt;h3 id=&quot;修改原生控件的布局&quot;&gt;&lt;a href=&quot;#修改原生控件的布局&quot; class=&quot;headerlink&quot; title=&quot;修改原生控件的布局&quot;&gt;&lt;/a&gt;修改原生控件的布局&lt;/h3&gt;&lt;p&gt;修改原生控件的布局情况在UIButton这个控件当中尤为明显。比如说UIButton的图片默认是居左显示的，那么有时候可能需要让图片居上，居下或者居右显示。这个时候你就可以选择修改原生控件的布局来结局这个问题。由于&lt;code&gt;layoutSubviews&lt;/code&gt;在以下几种情况下回自动调用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;init初始化不会出发layoutSubviews。但是用initWithFrame进行初始化的时候，如果rect的值不为CGRectZero时，也会触发。&lt;/li&gt;
&lt;li&gt;addSubview会触发layoutSubviews&lt;/li&gt;
&lt;li&gt;设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化&lt;/li&gt;
&lt;li&gt;滚动一个UIScrollView会触发layoutSubviews&lt;/li&gt;
&lt;li&gt;旋转UIScreen会触发父UIView的layoutSubviews事件&lt;/li&gt;
&lt;li&gt;改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上都是系统自动刷新，那么我们如何进行手动刷新呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;setNeedsLayout：标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但是layoutSubviews一定会被调用&lt;/li&gt;
&lt;li&gt;layoutIfNeeded：如果，有需要刷新的标记，立即调用layoutSubviews进行重新布局(如果没有标记，不会调用layoutSubviews)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>UIScrollView中键盘的显示和隐藏</title>
    <link href="http://sz8023.github.io/2015/12/03/iOS-%E9%94%AE%E7%9B%98UIKeyboard%E7%9A%84%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8F/"/>
    <id>http://sz8023.github.io/2015/12/03/iOS-键盘UIKeyboard的显示和隐藏/</id>
    <published>2015-12-03T09:54:14.000Z</published>
    <updated>2016-09-03T14:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>实际开发当中，经常会遇到需要显示和隐藏键盘的需求。那么在什么情况下需要隐藏键盘呢？<br>首先经常会弹出键盘的控件主要有<code>UITextField</code>、<code>UITextView</code>等。而这些控件的父控件要么是常规的视图，如<code>UIView</code>、<code>UIScrollView</code>或<code>UITableView</code>等。这个时候也许我们就要分2种情况来处理了。</p>
<h4 id="UIView处理方案"><a href="#UIView处理方案" class="headerlink" title="UIView处理方案"></a>UIView处理方案</h4><p>如果使用的是UIView而不是UIScrollView，那么实现方式很简单，只要重写这个方法处理键盘事件就可以了。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">        [textfield endEditing:<span class="literal">YES</span>];</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>但是上面的情况不会处理UIscrollView，因为：</p>
<ul>
<li>UIScrollView是UIView的子控件</li>
<li>UIScrollView会先接受触摸事件，并不会把UIEvent传递给UIView</li>
</ul>
<h4 id="UIScrollView处理方案"><a href="#UIScrollView处理方案" class="headerlink" title="UIScrollView处理方案"></a>UIScrollView处理方案</h4><p>UIScrollView如果只是在Drag的时候处理键盘，那么处理方式比较简单，你只需要做这样的一个简单设置即可</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">scrollView.keyboardDismissMode = <span class="built_in">UIScrollViewKeyboardDismissModeOnDrag</span>;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>但是如果你还想要给UIScrollView添加点击事件来处理键盘，那么你就需要给视图添加一个手势来识别它。Coding like this</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">UITapGestureRecognizer</span> *tapGesture = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(tapEvent:)];</div><div class="line">tapGesture.delegate = <span class="keyword">self</span>;</div><div class="line">tapGesture.numberOfTapsRequired = <span class="number">1</span>;</div><div class="line">tapGesture.numberOfTouchesRequired = <span class="number">1</span>;</div><div class="line">[scrollView addGestureRecognizer:tapGesture];</div></pre></td></tr></table></figure>
<p>然后在代理方法中你需要这样来处理</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tapEvent &#123;</div><div class="line">    [<span class="keyword">self</span>.view endEditing:<span class="literal">YES</span>];</div><div class="line"><span class="comment">//     或者想这样</span></div><div class="line"><span class="comment">//    [textField endEditing:YES];</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你将手势运用在UITableView中的话，那么cell可能就无法接收到点击事件了，也就是说方法<code>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath</code>走不通了。</p>
<p>为什么cell接收不到事件呢？可能你还需要了解这些知识<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html" target="_blank" rel="external">Responder Chain</a></p>
<p>针对这样的问题，你需要实现手势的代理方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class="built_in">UITouch</span> *)touch &#123;</div><div class="line">    <span class="comment">// 若为UITableViewCellContentView，就不接受tap事件</span></div><div class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>([touch.view <span class="keyword">class</span>]) isEqualToString:<span class="string">@"UITableViewCellContentView"</span>]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际开发当中，经常会遇到需要显示和隐藏键盘的需求。那么在什么情况下需要隐藏键盘呢？&lt;br&gt;首先经常会弹出键盘的控件主要有&lt;code&gt;UITextField&lt;/code&gt;、&lt;code&gt;UITextView&lt;/code&gt;等。而这些控件的父控件要么是常规的视图，如&lt;code&gt;UIView&lt;/code&gt;、&lt;code&gt;UIScrollView&lt;/code&gt;或&lt;code&gt;UITableView&lt;/code&gt;等。这个时候也许我们就要分2种情况来处理了。&lt;/p&gt;
&lt;h4 id=&quot;UIView处理方案&quot;&gt;&lt;a href=&quot;#UIView处理方案&quot; class=&quot;headerlink&quot; title=&quot;UIView处理方案&quot;&gt;&lt;/a&gt;UIView处理方案&lt;/h4&gt;&lt;p&gt;如果使用的是UIView而不是UIScrollView，那么实现方式很简单，只要重写这个方法处理键盘事件就可以了。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)touchesBegan:(&lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt; *)touches withEvent:(&lt;span class=&quot;built_in&quot;&gt;UIEvent&lt;/span&gt; *)event &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        [textfield endEditing:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是上面的情况不会处理UIscrollView，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UIScrollView是UIView的子控件&lt;/li&gt;
&lt;li&gt;UIScrollView会先接受触摸事件，并不会把UIEvent传递给UIView&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;UIScrollView处理方案&quot;&gt;&lt;a href=&quot;#UIScrollView处理方案&quot; class=&quot;headerlink&quot; title=&quot;UIScrollView处理方案&quot;&gt;&lt;/a&gt;UIScrollView处理方案&lt;/h4&gt;&lt;p&gt;UIScrollView如果只是在Drag的时候处理键盘，那么处理方式比较简单，你只需要做这样的一个简单设置即可&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;scrollView.keyboardDismissMode = &lt;span class=&quot;built_in&quot;&gt;UIScrollViewKeyboardDismissModeOnDrag&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="实用技巧" scheme="http://sz8023.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>手势解锁实现</title>
    <link href="http://sz8023.github.io/2015/11/12/iOS-%E6%89%8B%E5%8A%BF%E8%A7%A3%E9%94%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://sz8023.github.io/2015/11/12/iOS-手势解锁实现/</id>
    <published>2015-11-12T01:39:53.000Z</published>
    <updated>2016-09-02T03:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>如今很多涉及到安全方面的app都会有手势解锁这个功能。这个功能看似简单，其实还是有很多的注意点在里面。以下是我写的一个简单的手势解锁。</p>
<p>如果你需要改变根控制器的view，你可以自定义，我这边简单定义了一下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  BGView.m</span></div><div class="line"><span class="comment">//  05-手势解锁</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by styshy on 15/11/4.</span></div><div class="line"><span class="comment">//  Copyright (c) 2015年 sz. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"BGView.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BGView</span></span></div><div class="line"></div><div class="line"><span class="comment">// 在drawRect中绘制图片</span></div><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123;</div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Home_refresh_bg"</span>];</div><div class="line">    [image drawInRect:rect];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>主要的手势解锁在LockView这个类中，部分代码存在注释。这个LockView也是手势的主要绘制区域</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  LockView.m</span></div><div class="line"><span class="comment">//  05-手势解锁</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by styshy on 15/11/4.</span></div><div class="line"><span class="comment">//  Copyright (c) 2015年 sz. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"LockView.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LockView</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *buttons;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">CGPoint</span> curP;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LockView</span></span></div><div class="line"></div><div class="line"><span class="comment">// 懒加载</span></div><div class="line">- (<span class="built_in">NSMutableArray</span> *)buttons&#123;</div><div class="line">    <span class="keyword">if</span> (_buttons == <span class="literal">nil</span>) &#123;</div><div class="line">        _buttons = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _buttons;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 添加按钮</span></div><div class="line">- (<span class="keyword">void</span>)awakeFromNib&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++) &#123;</div><div class="line">        <span class="comment">// 创建按钮</span></div><div class="line">        <span class="built_in">UIButton</span> *button = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</div><div class="line">        </div><div class="line">        <span class="comment">// 设置按钮的背景图片</span></div><div class="line">        [button setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"gesture_node_normal"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">        [button setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"gesture_node_selected"</span>] forState:<span class="built_in">UIControlStateSelected</span>];</div><div class="line">        </div><div class="line">        [button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(btnClick:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">        </div><div class="line">        <span class="comment">// 将按钮添加到视图当中</span></div><div class="line">        [<span class="keyword">self</span> addSubview:button];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 按钮的高亮状态是系统自动达到的,当用户长按按钮的时候就会达到高亮状态</span></div><div class="line"><span class="comment">// 按钮的选中状态必须通过代码手动达到</span></div><div class="line">- (<span class="keyword">void</span>)btnClick:(<span class="built_in">UIButton</span> *)btn&#123;</div><div class="line">    btn.selected = <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 布局按钮</span></div><div class="line">- (<span class="keyword">void</span>)layoutSubviews&#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> layoutSubviews];</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> WH = <span class="number">74</span>;</div><div class="line">    <span class="built_in">CGFloat</span> btnX = <span class="number">0</span>;</div><div class="line">    <span class="built_in">CGFloat</span> btnY = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> totalCols = <span class="number">3</span>;</div><div class="line">    <span class="keyword">int</span> btnCol = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> btnRow = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> margin = (<span class="keyword">self</span>.bounds.size.width - totalCols * WH)/(totalCols + <span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)<span class="keyword">self</span>.subviews.count;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i ++) &#123;</div><div class="line">        <span class="comment">// 当前按钮的所在列</span></div><div class="line">        btnCol =(<span class="keyword">int</span>) i % totalCols;</div><div class="line">        <span class="comment">// 当前按钮所在行</span></div><div class="line">        btnRow = i / totalCols;</div><div class="line">        <span class="comment">// 当前按钮的x坐标</span></div><div class="line">        btnX = margin + btnCol * (margin + WH);</div><div class="line">        <span class="comment">// 当前按钮的y坐标</span></div><div class="line">        btnY = margin + btnRow * (margin + WH);</div><div class="line">        </div><div class="line">        <span class="built_in">UIButton</span> *button = <span class="keyword">self</span>.subviews[i];</div><div class="line">        </div><div class="line">        button.frame = <span class="built_in">CGRectMake</span>(btnX, btnY, WH,WH);</div><div class="line">        <span class="comment">// 将按钮的交互状态转给drawRect方法处理</span></div><div class="line">        button.userInteractionEnabled = <span class="literal">NO</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// 记录按钮，每个按钮都有一个数字标示</span></div><div class="line">        button.tag = i;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 手势移动</span></div><div class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    <span class="comment">// 获取手势</span></div><div class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</div><div class="line">    <span class="comment">// 获取当前的位置坐标</span></div><div class="line">    <span class="built_in">CGPoint</span> point = [touch locationInView:<span class="keyword">self</span>];</div><div class="line">    <span class="keyword">self</span>.curP = point;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIButton</span>* button <span class="keyword">in</span> <span class="keyword">self</span>.subviews) &#123;</div><div class="line">        <span class="comment">// 判断当前按钮是否被选中</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(button.frame, point)) &#123;</div><div class="line">            <span class="keyword">if</span> (button.selected == <span class="literal">NO</span>) &#123;</div><div class="line">                button.selected = <span class="literal">YES</span>;</div><div class="line">                [<span class="keyword">self</span>.buttons addObject:button];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 重回</span></div><div class="line">    [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 手势结束</span></div><div class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> string];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIButton</span> * btn <span class="keyword">in</span> <span class="keyword">self</span>.buttons) &#123;</div><div class="line">        [str appendFormat:<span class="string">@"%ld"</span>,btn.tag];</div><div class="line">        btn.selected = <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str);</div><div class="line">    </div><div class="line">    <span class="comment">// 清空所有的选中按钮</span></div><div class="line">    [<span class="keyword">self</span>.buttons removeAllObjects];</div><div class="line">    </div><div class="line">    <span class="comment">// 重新绘图</span></div><div class="line">    [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 绘图</span></div><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123;</div><div class="line">    <span class="comment">// 如果没有选中的按钮，则直接返回</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.buttons.count == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 创建路径</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *path = [[<span class="built_in">UIBezierPath</span> alloc] init];</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)<span class="keyword">self</span>.buttons.count;</div><div class="line">    </div><div class="line">    <span class="comment">// 去除path，绘制线条</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; count; i ++) &#123;</div><div class="line">        <span class="built_in">UIButton</span> *selectedBtn = <span class="keyword">self</span>.buttons[i];</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == i) &#123;</div><div class="line">            [path moveToPoint:selectedBtn.center];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            [path addLineToPoint:selectedBtn.center];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [path addLineToPoint:<span class="keyword">self</span>.curP];</div><div class="line">    </div><div class="line">    [path setLineWidth:<span class="number">8</span>];<span class="comment">// 设置线宽</span></div><div class="line">    [[<span class="built_in">UIColor</span> greenColor] set];<span class="comment">//设置线条颜色</span></div><div class="line">    [path stroke];<span class="comment">//绘制空心线条</span></div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>效果展示图片：</p>
<p><img src="../images/LockView.gif" alt="LockView"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如今很多涉及到安全方面的app都会有手势解锁这个功能。这个功能看似简单，其实还是有很多的注意点在里面。以下是我写的一个简单的手势解锁。&lt;/p&gt;
&lt;p&gt;如果你需要改变根控制器的view，你可以自定义，我这边简单定义了一下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  BGView.m&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  05-手势解锁&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  Created by styshy on 15/11/4.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  Copyright (c) 2015年 sz. All rights reserved.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&quot;BGView.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BGView&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在drawRect中绘制图片&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)drawRect:(&lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt;)rect&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; *image = [&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageNamed:&lt;span class=&quot;string&quot;&gt;@&quot;Home_refresh_bg&quot;&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [image drawInRect:rect];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="自定义库" scheme="http://sz8023.github.io/categories/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>SDWebImage学习</title>
    <link href="http://sz8023.github.io/2015/09/01/iOS-SDWebImage%E5%AD%A6%E4%B9%A0/"/>
    <id>http://sz8023.github.io/2015/09/01/iOS-SDWebImage学习/</id>
    <published>2015-08-31T23:42:53.000Z</published>
    <updated>2016-09-03T09:58:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="rs-SDWebImage"><a href="#rs-SDWebImage" class="headerlink" title="rs/SDWebImage"></a><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">rs/SDWebImage</a></h3><p><code>SDWebImage</code>是一个优秀的图片处理框架，你可以通过它来实现异步图片下载，并且支持图片的缓存。</p>
<p>这个第三方库为UIImageView提供了一个分类，支持处理来自网络的图片，主要功能包括以下几点：</p>
<ul>
<li>一个UIImageView的分类来添加图片和缓存处理</li>
<li>一个异步图片下载器</li>
<li>一个异步内存和磁盘图片缓存和对缓存过期的处理</li>
<li>支持Gif图片</li>
<li>支持WebP</li>
<li>背景图片解压</li>
<li>相同URL的图片不会下载多次</li>
<li>假的URL不会尝试一直请求</li>
<li>保证主线程不会卡死</li>
<li>……</li>
</ul>
<h3 id="应该如何使用"><a href="#应该如何使用" class="headerlink" title="应该如何使用"></a>应该如何使用</h3><p><code>SDWebImage</code>为使用者提供了<a href="http://cocoadocs.org/docsets/SDWebImage/3.8.1/" target="_blank" rel="external">API document</a>，以下只是简单列举以下最常见的用法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;SDWebImage/UIImageView+WebCache.h&gt;</span></span></div><div class="line">...</div><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">   <span class="keyword">static</span> <span class="built_in">NSString</span> *MyIdentifier = <span class="string">@"MyIdentifier"</span>;</div><div class="line"></div><div class="line">   <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];</div><div class="line">   <span class="keyword">if</span> (cell == <span class="literal">nil</span>) &#123;</div><div class="line">       cell = [[[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span></div><div class="line">                                      reuseIdentifier:MyIdentifier] autorelease];</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// Here we use the new provided sd_setImageWithURL: method to load the web image</span></div><div class="line">   [cell.imageView sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</div><div class="line">                     placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]];</div><div class="line"></div><div class="line">   cell.textLabel.text = <span class="string">@"My Text"</span>;</div><div class="line">   <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>或者通过使用block的形式</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Here we use the new provided sd_setImageWithURL: method to load the web image</span></div><div class="line">[cell.imageView sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</div><div class="line">                      placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]</div><div class="line">                             completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">                                ... completion code here ...</div><div class="line">                             &#125;];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;rs-SDWebImage&quot;&gt;&lt;a href=&quot;#rs-SDWebImage&quot; class=&quot;headerlink&quot; title=&quot;rs/SDWebImage&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/rs/SDWebImage&quot;&gt;rs/SDWebImage&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt;是一个优秀的图片处理框架，你可以通过它来实现异步图片下载，并且支持图片的缓存。&lt;/p&gt;
&lt;p&gt;这个第三方库为UIImageView提供了一个分类，支持处理来自网络的图片，主要功能包括以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个UIImageView的分类来添加图片和缓存处理&lt;/li&gt;
&lt;li&gt;一个异步图片下载器&lt;/li&gt;
&lt;li&gt;一个异步内存和磁盘图片缓存和对缓存过期的处理&lt;/li&gt;
&lt;li&gt;支持Gif图片&lt;/li&gt;
&lt;li&gt;支持WebP&lt;/li&gt;
&lt;li&gt;背景图片解压&lt;/li&gt;
&lt;li&gt;相同URL的图片不会下载多次&lt;/li&gt;
&lt;li&gt;假的URL不会尝试一直请求&lt;/li&gt;
&lt;li&gt;保证主线程不会卡死&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;应该如何使用&quot;&gt;&lt;a href=&quot;#应该如何使用&quot; class=&quot;headerlink&quot; title=&quot;应该如何使用&quot;&gt;&lt;/a&gt;应该如何使用&lt;/h3&gt;&lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt;为使用者提供了&lt;a href=&quot;http://cocoadocs.org/docsets/SDWebImage/3.8.1/&quot;&gt;API document&lt;/a&gt;，以下只是简单列举以下最常见的用法。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;SDWebImage/UIImageView+WebCache.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; *)tableView:(&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *)tableView cellForRowAtIndexPath:(&lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *)indexPath &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *MyIdentifier = &lt;span class=&quot;string&quot;&gt;@&quot;MyIdentifier&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cell == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       cell = [[[&lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; alloc] initWithStyle:&lt;span class=&quot;built_in&quot;&gt;UITableViewCellStyleDefault&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                      reuseIdentifier:MyIdentifier] autorelease];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// Here we use the new provided sd_setImageWithURL: method to load the web image&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   [cell.imageView sd_setImageWithURL:[&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;http://www.domain.com/path/to/image.jpg&quot;&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                     placeholderImage:[&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageNamed:&lt;span class=&quot;string&quot;&gt;@&quot;placeholder.png&quot;&lt;/span&gt;]];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   cell.textLabel.text = &lt;span class=&quot;string&quot;&gt;@&quot;My Text&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; cell;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="框架学习" scheme="http://sz8023.github.io/tags/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MJExtension学习</title>
    <link href="http://sz8023.github.io/2015/07/05/iOS-MJExtension%E5%AD%A6%E4%B9%A0/"/>
    <id>http://sz8023.github.io/2015/07/05/iOS-MJExtension学习/</id>
    <published>2015-07-05T10:24:10.000Z</published>
    <updated>2016-09-03T09:59:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CoderMJLee-MJExtension"><a href="#CoderMJLee-MJExtension" class="headerlink" title="CoderMJLee/MJExtension"></a><a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="external">CoderMJLee/MJExtension</a></h3><p>大神李明杰的另一个框架，实现Json和Model的互相转换，转换速度快、使用简单方便的字典转模型框架。</p>
<p><code>MJExtension</code>是一套字典和模型之间转换的超轻量级框架</p>
<ul>
<li>JSON –&gt; Model、Core Data Modal</li>
<li>JSONString –&gt; Model、Core Data Model</li>
<li>Model、Core Data Model –&gt; JSON</li>
<li>JSON Array –&gt; Model Array、Core Data Model Array</li>
<li>JSONString –&gt; Model Array、Core Data Model Array</li>
<li>Model Array、Core Data Model Array –&gt; JSON Array</li>
</ul>
<p>Coding all properties of model in one line code.<br>只需要一行代码，就能实现模型的所有属性进行Coding(归档和解档)</p>
<p>同样的，MJExtension也提供了两种使用方式，一种是通过CocoaPods，另一种是通过手动导入的方式。</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CoderMJLee-MJExtension&quot;&gt;&lt;a href=&quot;#CoderMJLee-MJExtension&quot; class=&quot;headerlink&quot; title=&quot;CoderMJLee/MJExtension&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/CoderMJLee/MJExtension&quot;&gt;CoderMJLee/MJExtension&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;大神李明杰的另一个框架，实现Json和Model的互相转换，转换速度快、使用简单方便的字典转模型框架。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MJExtension&lt;/code&gt;是一套字典和模型之间转换的超轻量级框架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSON –&amp;gt; Model、Core Data Modal&lt;/li&gt;
&lt;li&gt;JSONString –&amp;gt; Model、Core Data Model&lt;/li&gt;
&lt;li&gt;Model、Core Data Model –&amp;gt; JSON&lt;/li&gt;
&lt;li&gt;JSON Array –&amp;gt; Model Array、Core Data Model Array&lt;/li&gt;
&lt;li&gt;JSONString –&amp;gt; Model Array、Core Data Model Array&lt;/li&gt;
&lt;li&gt;Model Array、Core Data Model Array –&amp;gt; JSON Array&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Coding all properties of model in one line code.&lt;br&gt;只需要一行代码，就能实现模型的所有属性进行Coding(归档和解档)&lt;/p&gt;
&lt;p&gt;同样的，MJExtension也提供了两种使用方式，一种是通过CocoaPods，另一种是通过手动导入的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="框架学习" scheme="http://sz8023.github.io/tags/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MJRefresh学习</title>
    <link href="http://sz8023.github.io/2015/06/30/iOS-MJRefresh%E5%AD%A6%E4%B9%A0/"/>
    <id>http://sz8023.github.io/2015/06/30/iOS-MJRefresh学习/</id>
    <published>2015-06-30T02:41:24.000Z</published>
    <updated>2016-09-03T09:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CoderMJLee-MJRefresh"><a href="#CoderMJLee-MJRefresh" class="headerlink" title="CoderMJLee/MJRefresh"></a><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="external">CoderMJLee/MJRefresh</a></h3><p>大神李明杰写的一个刷新控件造福了国内的一批程序员，也提高了我们开发项目的进度。</p>
<p><code>MJRefresh</code>的使用方式特别的简单，看看官网你就可以知道如何使用了。</p>
<p><code>MJRefresh</code>支持的刷新控件有：</p>
<ul>
<li>UIScrollView</li>
<li>UITableView</li>
<li>UICollectionView</li>
<li>UIWebView</li>
</ul>
<p>像很多牛逼的第三方一样，<code>MJRefresh</code>也提供了两种使用方式，你可以通过CocoaPods或者手动导入的方式来使用它。</p>
<h3 id="MJRefresh框架的结构图"><a href="#MJRefresh框架的结构图" class="headerlink" title="MJRefresh框架的结构图"></a>MJRefresh框架的结构图</h3><p><img src="../images/MJRefresh.png" width="800px"></p>
<p>使用者可以从这个结构图中清晰的看到自己想要使用的Class，甚至可以根据相应的结构来自己定义刷新控件。</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CoderMJLee-MJRefresh&quot;&gt;&lt;a href=&quot;#CoderMJLee-MJRefresh&quot; class=&quot;headerlink&quot; title=&quot;CoderMJLee/MJRefresh&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/CoderMJLee/MJRefresh&quot;&gt;CoderMJLee/MJRefresh&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;大神李明杰写的一个刷新控件造福了国内的一批程序员，也提高了我们开发项目的进度。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MJRefresh&lt;/code&gt;的使用方式特别的简单，看看官网你就可以知道如何使用了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MJRefresh&lt;/code&gt;支持的刷新控件有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UIScrollView&lt;/li&gt;
&lt;li&gt;UITableView&lt;/li&gt;
&lt;li&gt;UICollectionView&lt;/li&gt;
&lt;li&gt;UIWebView&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;像很多牛逼的第三方一样，&lt;code&gt;MJRefresh&lt;/code&gt;也提供了两种使用方式，你可以通过CocoaPods或者手动导入的方式来使用它。&lt;/p&gt;
&lt;h3 id=&quot;MJRefresh框架的结构图&quot;&gt;&lt;a href=&quot;#MJRefresh框架的结构图&quot; class=&quot;headerlink&quot; title=&quot;MJRefresh框架的结构图&quot;&gt;&lt;/a&gt;MJRefresh框架的结构图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;../images/MJRefresh.png&quot; width=800px&gt;&lt;/p&gt;
&lt;p&gt;使用者可以从这个结构图中清晰的看到自己想要使用的Class，甚至可以根据相应的结构来自己定义刷新控件。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="框架学习" scheme="http://sz8023.github.io/tags/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Ruby教程</title>
    <link href="http://sz8023.github.io/2015/05/01/Ruby%E6%95%99%E7%A8%8B/"/>
    <id>http://sz8023.github.io/2015/05/01/Ruby教程/</id>
    <published>2015-05-01T01:46:31.000Z</published>
    <updated>2016-08-31T10:02:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Ruby教程"><a href="#Ruby教程" class="headerlink" title="Ruby教程"></a>Ruby教程</h3><p>Ruby是一种开源的面向对象程序设计的服务器端脚本语言。Ruby可运行于多种平台，如Windowss、MAC OS和UNIX的各种版本。</p>
<h3 id="编译-执行Ruby程序"><a href="#编译-执行Ruby程序" class="headerlink" title="编译/执行Ruby程序"></a>编译/执行Ruby程序</h3><p>Ruby与Smalltalk一样，是一个完美的面向对象语言，使用Ruby的语法比使用Smalltalk的语法要容易多。</p>
<h3 id="Ruby的特性"><a href="#Ruby的特性" class="headerlink" title="Ruby的特性"></a>Ruby的特性</h3><ul>
<li>Ruby是开源的，在Web上是免费提供的，但需要一个许可证。</li>
<li>Ruby是一种通用 、解释的编程语言。</li>
<li>Ruby是一种真正的面向对象编程语言。</li>
<li>Ruby是一种类似于Python和Perl的服务器端脚本语言</li>
<li>Ruby可以用来编写通用网关接口</li>
<li>Ruby可以被嵌套</li>
<li>……</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Ruby教程&quot;&gt;&lt;a href=&quot;#Ruby教程&quot; class=&quot;headerlink&quot; title=&quot;Ruby教程&quot;&gt;&lt;/a&gt;Ruby教程&lt;/h3&gt;&lt;p&gt;Ruby是一种开源的面向对象程序设计的服务器端脚本语言。Ruby可运行于多种平台，如Windowss、MAC
    
    </summary>
    
      <category term="Ruby教程" scheme="http://sz8023.github.io/categories/Ruby%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>NPM使用介绍</title>
    <link href="http://sz8023.github.io/2015/04/26/NPM%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://sz8023.github.io/2015/04/26/NPM使用介绍/</id>
    <published>2015-04-26T01:08:19.000Z</published>
    <updated>2016-08-31T10:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js-PEPL-交互式解释器"><a href="#Node-js-PEPL-交互式解释器" class="headerlink" title="Node.js PEPL(交互式解释器)"></a>Node.js PEPL(交互式解释器)</h1><p>我们可以在终端输入命令，并接收系统的响应<br>Node自带了交互式解释器，可以执行如下任务</p>
<ul>
<li>读取 - 读取用户输入，解析输入了JavaScript数据结构并存储在内存中</li>
<li>执行 - 执行输入的用户结构</li>
<li>打印 - 输出结果</li>
<li>循环 - 循环操作以上步骤知道用户两次按下ctrl+c 按钮退出</li>
</ul>
<p>我们可以输入以下命令来启动Node终端</p>
<pre><code>$ node
&gt;
</code></pre><h2 id="Node-js回调函数"><a href="#Node-js回调函数" class="headerlink" title="Node.js回调函数"></a>Node.js回调函数</h2><ul>
<li>Node.js异步编程的直接体现就是回调</li>
<li>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。</li>
<li>回调函数在完成任务之后就会被调用，Node使用了大量的回调函数，Node所有的API都支持回调函数。</li>
</ul>
<h3 id="阻塞代码"><a href="#阻塞代码" class="headerlink" title="阻塞代码"></a>阻塞代码</h3><pre><code>var fs = require(&quot;fs&quot;);
var data = fs.readFileSync(&apos;input.txt&apos;);

console.log(data.toString());
console.log(&quot;程序执行结束&quot;);
</code></pre><h3 id="非阻塞代码"><a href="#非阻塞代码" class="headerlink" title="非阻塞代码"></a>非阻塞代码</h3><pre><code>var fs = require(&quot;fs&quot;);

fs.readFile(&apos;input.txt&apos;,function(err,data) {
    if(err) return console.error(err);
    console.log(data.toString());
});

console.log(&quot;程序执行结束&quot;);
</code></pre><p><em>第一个实例在文件读取之后才执行程序。第二个实例我们不需要等待文件读取完成，这样就可以在读取文件的同时执行接下来的代码</em></p>
<h3 id="Node-js事件循环"><a href="#Node-js事件循环" class="headerlink" title="Node.js事件循环"></a>Node.js事件循环</h3><ul>
<li>Node.js是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。</li>
<li>Node.js的每一个API都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。</li>
<li>Node.js基本上所有的事件机制都是通过设计模式中的观察者模式实现</li>
<li>Node.js单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数。</li>
</ul>
<h3 id="随便"><a href="#随便" class="headerlink" title="随便"></a>随便</h3><pre><code>小到一个变量，数组，大到一个数据库或者网络通信，都离不开数据的增删改查。变量有，数据库也有。网络通信也有。GET,PUT,DELETE,POST
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Node-js-PEPL-交互式解释器&quot;&gt;&lt;a href=&quot;#Node-js-PEPL-交互式解释器&quot; class=&quot;headerlink&quot; title=&quot;Node.js PEPL(交互式解释器)&quot;&gt;&lt;/a&gt;Node.js PEPL(交互式解释器)&lt;/h1&gt;&lt;p&gt;
    
    </summary>
    
      <category term="Node教程" scheme="http://sz8023.github.io/categories/Node%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js笔记</title>
    <link href="http://sz8023.github.io/2015/04/25/Node%E6%95%99%E7%A8%8B/"/>
    <id>http://sz8023.github.io/2015/04/25/Node教程/</id>
    <published>2015-04-25T09:26:39.000Z</published>
    <updated>2016-08-31T12:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js应用有哪几部分组成"><a href="#Node-js应用有哪几部分组成" class="headerlink" title="Node.js应用有哪几部分组成"></a>Node.js应用有哪几部分组成</h1><ul>
<li>引入require模块：</li>
<li>创建服务器：服务器可以监听客户端的请求</li>
<li>接收请求与相应请求</li>
</ul>
<h2 id="创建node-js应用"><a href="#创建node-js应用" class="headerlink" title="创建node.js应用"></a>创建node.js应用</h2><ol>
<li>我们使用require</li>
</ol>
<h3 id="NPM使用介绍"><a href="#NPM使用介绍" class="headerlink" title="NPM使用介绍"></a>NPM使用介绍</h3><p>NPM(Node Package Manager)是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景如下</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用</li>
<li>允许用户从NPM服务器下载并安装别人编写好的命令行程序到本地使用</li>
<li>允许用户将自己编写好的包或命令行程序上传到NPM服务器供别人使用</li>
</ul>
<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><ul>
<li>简单的说Node.js是运行在服务器端的JavaScript</li>
<li>Node.js是一个事件驱动I/O服务器端JavaScript环境，基于Google的V8引擎，V8引擎执行JavaScript的速度非常快，性能非常快</li>
</ul>
<h2 id="使用版本"><a href="#使用版本" class="headerlink" title="使用版本"></a>使用版本</h2><p>我们可以使用一下命令来查看当前的Node版本</p>
<pre><code>node -v 
</code></pre><p>Note:不同版本可能有差异的</p>
<h3 id="脚本模式"><a href="#脚本模式" class="headerlink" title="脚本模式"></a>脚本模式</h3><pre><code>console.log(&quot;Hello, World&quot;);
</code></pre><h3 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h3><h1 id="什么是Web服务器"><a href="#什么是Web服务器" class="headerlink" title="什么是Web服务器"></a>什么是Web服务器</h1><p><code>Web服务器</code>一般指的是网站服务器，是指驻留在因特网上某种类型的计算机的程序，<code>Web服务器</code>的基本功能就是提供Web信息浏览功能服务。</p>
<p><strong>Web架构</strong><br><!--![web_architecture](../images/web_architecture.jpg)--></p>
<p><img src="../images/web_architecture.jpg" width="600px"></p>
<a id="more"></a>
<h3 id="使用Node创建Web服务"><a href="#使用Node创建Web服务" class="headerlink" title="使用Node创建Web服务"></a>使用Node创建Web服务</h3><p>Node.js提供了http模块，http模块主要用于搭建HTTP服务器和客户端，使用HTTP服务器或客户端功能必须调用HTTP模块。代码如下</p>
<pre><code>var http = require(&apos;http&apos;);
</code></pre><h3 id="使用Node创建Web客户端"><a href="#使用Node创建Web客户端" class="headerlink" title="使用Node创建Web客户端"></a>使用Node创建Web客户端</h3><p>Node.js创建Web客户端需要引入http模块，创建client.js文件，代码如下所示：    </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Node-js应用有哪几部分组成&quot;&gt;&lt;a href=&quot;#Node-js应用有哪几部分组成&quot; class=&quot;headerlink&quot; title=&quot;Node.js应用有哪几部分组成&quot;&gt;&lt;/a&gt;Node.js应用有哪几部分组成&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;引入require模块：&lt;/li&gt;
&lt;li&gt;创建服务器：服务器可以监听客户端的请求&lt;/li&gt;
&lt;li&gt;接收请求与相应请求&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;创建node-js应用&quot;&gt;&lt;a href=&quot;#创建node-js应用&quot; class=&quot;headerlink&quot; title=&quot;创建node.js应用&quot;&gt;&lt;/a&gt;创建node.js应用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;我们使用require&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;NPM使用介绍&quot;&gt;&lt;a href=&quot;#NPM使用介绍&quot; class=&quot;headerlink&quot; title=&quot;NPM使用介绍&quot;&gt;&lt;/a&gt;NPM使用介绍&lt;/h3&gt;&lt;p&gt;NPM(Node Package Manager)是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许用户从NPM服务器下载别人编写的第三方包到本地使用&lt;/li&gt;
&lt;li&gt;允许用户从NPM服务器下载并安装别人编写好的命令行程序到本地使用&lt;/li&gt;
&lt;li&gt;允许用户将自己编写好的包或命令行程序上传到NPM服务器供别人使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Node-js&quot;&gt;&lt;a href=&quot;#Node-js&quot; class=&quot;headerlink&quot; title=&quot;Node.js&quot;&gt;&lt;/a&gt;Node.js&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;简单的说Node.js是运行在服务器端的JavaScript&lt;/li&gt;
&lt;li&gt;Node.js是一个事件驱动I/O服务器端JavaScript环境，基于Google的V8引擎，V8引擎执行JavaScript的速度非常快，性能非常快&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;使用版本&quot;&gt;&lt;a href=&quot;#使用版本&quot; class=&quot;headerlink&quot; title=&quot;使用版本&quot;&gt;&lt;/a&gt;使用版本&lt;/h2&gt;&lt;p&gt;我们可以使用一下命令来查看当前的Node版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node -v 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note:不同版本可能有差异的&lt;/p&gt;
&lt;h3 id=&quot;脚本模式&quot;&gt;&lt;a href=&quot;#脚本模式&quot; class=&quot;headerlink&quot; title=&quot;脚本模式&quot;&gt;&lt;/a&gt;脚本模式&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;console.log(&amp;quot;Hello, World&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;交互模式&quot;&gt;&lt;a href=&quot;#交互模式&quot; class=&quot;headerlink&quot; title=&quot;交互模式&quot;&gt;&lt;/a&gt;交互模式&lt;/h3&gt;&lt;h1 id=&quot;什么是Web服务器&quot;&gt;&lt;a href=&quot;#什么是Web服务器&quot; class=&quot;headerlink&quot; title=&quot;什么是Web服务器&quot;&gt;&lt;/a&gt;什么是Web服务器&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Web服务器&lt;/code&gt;一般指的是网站服务器，是指驻留在因特网上某种类型的计算机的程序，&lt;code&gt;Web服务器&lt;/code&gt;的基本功能就是提供Web信息浏览功能服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Web架构&lt;/strong&gt;&lt;br&gt;&lt;!--![web_architecture](../images/web_architecture.jpg)--&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/web_architecture.jpg&quot; width=600px &gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Node教程" scheme="http://sz8023.github.io/categories/Node%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>HTML5教程</title>
    <link href="http://sz8023.github.io/2015/03/02/Html5%E6%95%99%E7%A8%8B/"/>
    <id>http://sz8023.github.io/2015/03/02/Html5教程/</id>
    <published>2015-03-02T05:42:39.000Z</published>
    <updated>2016-10-12T15:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML5教程"><a href="#HTML5教程" class="headerlink" title="HTML5教程"></a>HTML5教程</h3><p>你可以使用HTML来创建自己的WEB站点。<br>HTML5是HTML最新的修订版，HTML5的设计目的是为了在<strong>移动设备上支持多媒体。</strong></p>
<p>HTML5是W3C与WHATWG合作的结果。<br>WHATWG致力于web表单和应用程序，而W3C专注于XHTML2.0。</p>
<p>HTML5中的一些有趣的新特性：</p>
<ul>
<li>用于会话的canvas元素</li>
<li>用于媒介回放的video和audio元素</li>
<li>对本地离线存储的跟好的支持</li>
<li>新的特殊内容元素，比如article、footer、header、nav、section</li>
<li>新的表单控件，比如calendar、date、time、email、url、search</li>
</ul>
<a id="more"></a>
<h3 id="HTML5-lt-DOCTYPE"><a href="#HTML5-lt-DOCTYPE" class="headerlink" title="HTML5\&lt;!DOCTYPE>"></a>HTML5\&lt;!DOCTYPE></h3><p>\&lt;!DOCTYPE>声明必须位于HTML5文档中的第一行，使用非常简单。</p>
<p>```<br>\&lt;!DOCTYPE HTML></p>
<p>```</p>
<h3 id="HTML5浏览器支持"><a href="#HTML5浏览器支持" class="headerlink" title="HTML5浏览器支持"></a>HTML5浏览器支持</h3><p>最新版的Safari、Chrome、Firefox以及Opera支持某些HTML5特性。Internet Explorer 9将支持某些HTML5特性。</p>
<p><img src="../images/browsers_say.png" alt="支持哪些浏览器"></p>
<p>不论旧的和最新的浏览器，对无法识别的元素会作为内联元素自动处理。正因为如此，你可以“教会”浏览器处理“未知”的HTML元素。</p>
<h3 id="HTML5新元素"><a href="#HTML5新元素" class="headerlink" title="HTML5新元素"></a>HTML5新元素</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTML5教程&quot;&gt;&lt;a href=&quot;#HTML5教程&quot; class=&quot;headerlink&quot; title=&quot;HTML5教程&quot;&gt;&lt;/a&gt;HTML5教程&lt;/h3&gt;&lt;p&gt;你可以使用HTML来创建自己的WEB站点。&lt;br&gt;HTML5是HTML最新的修订版，HTML5的设计目的是为了在&lt;strong&gt;移动设备上支持多媒体。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTML5是W3C与WHATWG合作的结果。&lt;br&gt;WHATWG致力于web表单和应用程序，而W3C专注于XHTML2.0。&lt;/p&gt;
&lt;p&gt;HTML5中的一些有趣的新特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于会话的canvas元素&lt;/li&gt;
&lt;li&gt;用于媒介回放的video和audio元素&lt;/li&gt;
&lt;li&gt;对本地离线存储的跟好的支持&lt;/li&gt;
&lt;li&gt;新的特殊内容元素，比如article、footer、header、nav、section&lt;/li&gt;
&lt;li&gt;新的表单控件，比如calendar、date、time、email、url、search&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="HTML5教程" scheme="http://sz8023.github.io/categories/HTML5%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello,Hexo</title>
    <link href="http://sz8023.github.io/2015/02/25/Hexo%E6%95%99%E7%A8%8B/"/>
    <id>http://sz8023.github.io/2015/02/25/Hexo教程/</id>
    <published>2015-02-25T06:16:30.000Z</published>
    <updated>2016-10-12T14:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p>``` bash<br>$ hexo new “My New Post”<br>```</p>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p>``` bash<br>$ hexo server<br>```</p>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><p>``` bash<br>$ hexo generate<br>```</p>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p>``` bash<br>$ hexo deploy<br>```</p>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
      <category term="Hexo教程" scheme="http://sz8023.github.io/categories/Hexo%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
</feed>
