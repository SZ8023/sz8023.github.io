<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ForYou</title>
  <subtitle>如果一个人活得很诚恳，那么他一定生活在别处</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sz8023.github.io/"/>
  <updated>2018-04-24T06:07:18.668Z</updated>
  <id>http://sz8023.github.io/</id>
  
  <author>
    <name>styshy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java_反射</title>
    <link href="http://sz8023.github.io/2018/04/24/undefined/"/>
    <id>http://sz8023.github.io/2018/04/24/undefined/</id>
    <published>2018-04-24T06:07:18.000Z</published>
    <updated>2018-04-24T06:07:18.668Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java基础知识</title>
    <link href="http://sz8023.github.io/2018/04/24/java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://sz8023.github.io/2018/04/24/java-基础知识/</id>
    <published>2018-04-24T06:05:17.000Z</published>
    <updated>2018-05-03T15:06:30.680Z</updated>
    
    <content type="html"><![CDATA[<p>2018年04月27日，可以预见的未来。<br>今年需要抽出6个月的时间来学习java，之后在有机会的情况下可以选择跳槽。<br>如果今年不转java，或者不学习java，可以说又浪费了一年，然后明天的这个时候你依然只是一个iOS开发者。</p>
<ul>
<li>java为主</li>
<li>english和taglog为辅</li>
</ul>
<blockquote>
<p>java中浮点数的比较要特别注意，因为浮点数存在精度的问题，所以一般我们都会这么做</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">float</span> a = <span class="number">3.14f</span>;</div><div class="line"><span class="keyword">if</span>(a &gt; <span class="number">3.1</span> || a &lt; <span class="number">3.2</span>) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="视频03A-04-24"><a href="#视频03A-04-24" class="headerlink" title="视频03A(04.24)"></a>视频03A(04.24)</h3><blockquote>
<p>面向对象的特向》封装</p>
</blockquote>
<ul>
<li><p>== 和 equal的区别</p>
</li>
<li><p>finalize方法的调用时机</p>
<p>  可以通过调用系统的<code>System.gc</code>告诉系统需要进行垃圾回收了</p>
</li>
<li><p><code>this.name = name</code> 中<code>this</code>的作用</p>
</li>
</ul>
<h3 id="视频03B-04-24"><a href="#视频03B-04-24" class="headerlink" title="视频03B(04.24)"></a>视频03B(04.24)</h3><blockquote>
<p>基本数据类型 &amp; 引用数据类型    </p>
</blockquote>
<ul>
<li>基本数据类型作为参数传递和引用数据类型作为参数传递</li>
<li>static修饰成员变量的时候，成员变量修饰符跟这个关系不大，依然表示的是这个变量是这个类的所有对象共同持有。</li>
<li><a href="![https://blog.csdn.net/u012585964/article/details/52011138]">java的反射机制</a>，这个特性特别重要，</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">	<span class="comment">// 静态成员变量，所有的对象共同持有的，不论创建多少个对象，在内存中值存在一份，</span></div><div class="line">	<span class="comment">// 可以通过对象直接访问,也可以通过Student.count的形式访问，建议通过Student.count的方式访问</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">	</div><div class="line">	<span class="comment">// 所有的对象都有一个共同的country属性，可以通过</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String country = <span class="string">"Chinese"</span>;	</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</div><div class="line">		Student.count++;</div><div class="line">		System.out.println(Student.count);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] arge)</span> </span>&#123;</div><div class="line">		<span class="keyword">new</span> Student();</div><div class="line">		<span class="keyword">new</span> Student();</div><div class="line">		<span class="keyword">new</span> Student();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<!--阅读全文-->
<ul>
<li><p><a href="http://www.importnew.com/13504.html" target="_blank" rel="external">java回收机制</a></p>
<p>  <a href="http://www.importnew.com/13493.html" target="_blank" rel="external">Java垃圾回收是如何工作的</a><br>  java的回收机制分为4个系列，</p>
</li>
<li><p>java内部类，javadoc的文档使用，java单列的书写模式</p>
</li>
</ul>
<h3 id="视频04A-04-26"><a href="#视频04A-04-26" class="headerlink" title="视频04A(04.26)"></a>视频04A(04.26)</h3><blockquote>
<p>高级特性》类的继承；<br>java中通过继承可以简化类的书写，java中只允许单继承，</p>
</blockquote>
<ul>
<li>访问修饰符</li>
</ul>
<table>
<thead>
<tr>
<th>作用域</th>
<th>当前类</th>
<th>同包</th>
<th>子类</th>
<th>其他包</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>x</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<p><a href="https://blog.csdn.net/qq_29513537/article/details/69677011" target="_blank" rel="external">访问修饰符详解</a></p>
<p>如果没有任何修饰符，默认是default，有时候我们写的子类可以调用父类的default修饰的成员变量和方法，这是因为这个子类和父类在同一个包中，所以可以访问。</p>
<ul>
<li><p><code>final</code>修饰符的使用</p>
<p>  <code>final</code>修饰的类不可以被继承；<code>final</code>修饰的方法可以被继承但是不可以被重写；</p>
</li>
<li><p>抽象类和抽象方法</p>
<p>  含有抽象方法的类必须声明为抽象类；而抽象类里面不一定有抽象方法</p>
</li>
<li><p>接口<code>interface</code></p>
</li>
<li><p>匿名内部类</p>
</li>
</ul>
<h3 id="视频04B-04-26"><a href="#视频04B-04-26" class="headerlink" title="视频04B(04.26)"></a>视频04B(04.26)</h3><blockquote>
<p><code>java</code>中的异常捕获</p>
</blockquote>
<ul>
<li><p>try…catch</p>
<p>  如果某个人写了一个接口，另一个人需要调用这个接口，那么他怎么知道这个接口会抛出异常，这个时候就需要在定义这个接口的时候在函数的后面加上<code>throws Exception</code>，这样调用者就知道这个函数如果调用可能会发生异常，所以在调用这个函数的时候就需要加上<code>try...catch...</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> com.ycit.one;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		<span class="keyword">int</span> result = x/y;</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">new</span> Test().divide(<span class="number">20</span>, <span class="number">0</span>);</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"pragram is running here!"</span>);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>import</code>关键词，引用父包之后，子包中的类并没被引用，需要在引用一次；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.*;</div><div class="line"><span class="keyword">import</span> java.awt.event.*;</div></pre></td></tr></table></figure>
<ul>
<li><p>当引用的多个包中包含相同的类的时候，在使用类的时候就需要具体指出用的是哪个包中的类 <code>java.sql.Date</code>和    <code>java.util.Date</code>像这样使用该类</p>
</li>
<li><p>如果在程序中找不到某个类：①类名写错②没有import类所在的包③classpath的设置问题</p>
</li>
<li><p><code>jar</code>文件的使用， 压缩<code>class</code>文件，解压<code>class</code>文件；这个jar.exe的功能跟平常的压缩类软件功能一样。</p>
</li>
</ul>
<h3 id="视频05-05-03"><a href="#视频05-05-03" class="headerlink" title="视频05(05.03)"></a>视频05(05.03)</h3><blockquote>
<p>java中的多线程，这个问题应该是很重要了</p>
</blockquote>
<p>*</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018年04月27日，可以预见的未来。&lt;br&gt;今年需要抽出6个月的时间来学习java，之后在有机会的情况下可以选择跳槽。&lt;br&gt;如果今年不转java，或者不学习java，可以说又浪费了一年，然后明天的这个时候你依然只是一个iOS开发者。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java
    
    </summary>
    
      <category term="java" scheme="http://sz8023.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Xcode8相关问题汇总</title>
    <link href="http://sz8023.github.io/2016/09/22/iOS-20160922Xcode8%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://sz8023.github.io/2016/09/22/iOS-20160922Xcode8相关问题汇总/</id>
    <published>2016-09-22T01:14:46.000Z</published>
    <updated>2016-10-27T10:59:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天很多苹果开发的小伙伴迫不及待的升级了Xcode8，可是升级完成之后项目中也遇到了很多小问题，下面就一一列举相关问题。</p>
<p>如果你的项目中访问了相机，相册，麦克风等设备，你需要在info.plist文件里做先关配置，如果没有配置相关信息，程序会直接退出。</p>
<h5 id="访问相机"><a href="#访问相机" class="headerlink" title="访问相机"></a><a href="https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html" target="_blank" rel="external">访问相机</a></h5><blockquote>
<p>Important: To protect user privacy, an iOS app linked on or after iOS 10.0, and which accesses the device’s camera, must statically declare the intent to do so. Include the NSCameraUsageDescription key in your app’s Info.plist file and provide a purpose string for this key. If your app attempts to access the device’s camera without a corresponding purpose string, your app exits.</p>
</blockquote>
<p>根据苹果的描述信息，你需要在info.plist文件里面做相关配置。</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;</div><div class="line">&lt;string&gt;允许此权限才能使用相机&lt;/string&gt;</div></pre></td></tr></table></figure>
<h5 id="访问相册"><a href="#访问相册" class="headerlink" title="访问相册"></a>访问相册</h5><p>此处相关链接可以参考访问相机，以下连接相同。</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;</div><div class="line">&lt;string&gt;允许此权限才能访问相册&lt;/string&gt;</div></pre></td></tr></table></figure>
<h5 id="访问麦克风"><a href="#访问麦克风" class="headerlink" title="访问麦克风"></a>访问麦克风</h5><a id="more"></a>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;</div><div class="line">&lt;string&gt;允许此权限才能使用麦克风&lt;/string&gt;</div></pre></td></tr></table></figure>
<p>还有其他的权限，比如媒体库，蓝牙，日历，健康等，更多权限参考<a href="https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html" target="_blank" rel="external">Information Property List Key Reference</a></p>
<h5 id="Xcode8禁止控制台打印干扰信息"><a href="#Xcode8禁止控制台打印干扰信息" class="headerlink" title="Xcode8禁止控制台打印干扰信息"></a>Xcode8禁止控制台打印干扰信息</h5><p><strong>Product》Scheme》Edit Scheme…</strong> ，Run标签栏中选择Arguments选项卡，在Environments Variables 中添加字典<code>OS_ACTIVITY_MODE=disable</code></p>
<ul>
<li>Name:OS_ACTIVITY_MODE</li>
<li>Value:disable</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="http://blog.csdn.net/u012681458/article/details/51865435" target="_blank" rel="external">升级Xcode8后的相机crash问题-IOS10权限问题</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天很多苹果开发的小伙伴迫不及待的升级了Xcode8，可是升级完成之后项目中也遇到了很多小问题，下面就一一列举相关问题。&lt;/p&gt;
&lt;p&gt;如果你的项目中访问了相机，相册，麦克风等设备，你需要在info.plist文件里做先关配置，如果没有配置相关信息，程序会直接退出。&lt;/p&gt;
&lt;h5 id=&quot;访问相机&quot;&gt;&lt;a href=&quot;#访问相机&quot; class=&quot;headerlink&quot; title=&quot;访问相机&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html&quot;&gt;访问相机&lt;/a&gt;&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;Important: To protect user privacy, an iOS app linked on or after iOS 10.0, and which accesses the device’s camera, must statically declare the intent to do so. Include the NSCameraUsageDescription key in your app’s Info.plist file and provide a purpose string for this key. If your app attempts to access the device’s camera without a corresponding purpose string, your app exits.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据苹果的描述信息，你需要在info.plist文件里面做相关配置。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;key&amp;gt;NSCameraUsageDescription&amp;lt;/key&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;string&amp;gt;允许此权限才能使用相机&amp;lt;/string&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;访问相册&quot;&gt;&lt;a href=&quot;#访问相册&quot; class=&quot;headerlink&quot; title=&quot;访问相册&quot;&gt;&lt;/a&gt;访问相册&lt;/h5&gt;&lt;p&gt;此处相关链接可以参考访问相机，以下连接相同。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;key&amp;gt;NSPhotoLibraryUsageDescription&amp;lt;/key&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;string&amp;gt;允许此权限才能访问相册&amp;lt;/string&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;访问麦克风&quot;&gt;&lt;a href=&quot;#访问麦克风&quot; class=&quot;headerlink&quot; title=&quot;访问麦克风&quot;&gt;&lt;/a&gt;访问麦克风&lt;/h5&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>objc常见开发总结</title>
    <link href="http://sz8023.github.io/2016/07/02/iOS-20161102objc%E5%B8%B8%E8%A7%81%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>http://sz8023.github.io/2016/07/02/iOS-20161102objc常见开发总结/</id>
    <published>2016-07-02T11:44:46.000Z</published>
    <updated>2016-11-14T13:26:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于自定义UIView"><a href="#关于自定义UIView" class="headerlink" title="关于自定义UIView"></a>关于自定义UIView</h3><h4 id="通过xib"><a href="#通过xib" class="headerlink" title="通过xib"></a>通过xib</h4><pre><code>如果其他开发人员不知道你是通过xib创建的cell，或者其他开发人员不小心使用了`initWithFrame`的创建方式，那么你可以通过这样来保证他们通过xib来创建的UIView。
</code></pre><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</div><div class="line"><span class="keyword">self</span> = [[<span class="built_in">NSBundle</span> mainBundle]loadNibNamed:<span class="string">@"YourCustomViewName"</span> owner:<span class="keyword">self</span> options:<span class="literal">nil</span>].lastObject;</div><div class="line"><span class="keyword">self</span>.frame = frame;</div><div class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="automaticallyAdjustsScrollViewInsets"><a href="#automaticallyAdjustsScrollViewInsets" class="headerlink" title="automaticallyAdjustsScrollViewInsets"></a>automaticallyAdjustsScrollViewInsets</h3><p>这个属性的默认值是YES，如果你的UIScrollView出现莫名的错位，可以检查这个属性是不是设置错了。这个属性告诉当前的控制器是否需要调整他内部滚动视图的内边距（主要的滚动视图也就是UIScrollView或者其子类）</p>
<blockquote>
<p>The default value of this property is YES, which lets container view controllers know that they should adjust the scroll view insets of this view controller’s view to account for screen areas consumed by a status bar, search bar, navigation bar, toolbar, or tab bar. Set this property to NO if your view controller implementation manages its own scroll view inset adjustments.</p>
</blockquote>
<a id="more"></a>
<p>不才做一下翻译：这个属性的默认值是YES，告诉容器视图控制器调整滚动视图到这个正在显示控制器视图(应该是控制器的根视图)内边距。</p>
<h3 id="UITableView分组问题"><a href="#UITableView分组问题" class="headerlink" title="UITableView分组问题"></a>UITableView分组问题</h3><h4 id="设置SectionHeader或SectionFooter高度"><a href="#设置SectionHeader或SectionFooter高度" class="headerlink" title="设置SectionHeader或SectionFooter高度"></a>设置SectionHeader或SectionFooter高度</h4><p>如果你在开发中遇到了tableView分组的情况，那么在设置section头部或者尾部的时候一定要注意了，千万不要使用系统提供的<code>tableView.sectionHeaderHeight</code>和<code>tableView.sectionFooterHeight</code>来设置高度，一定要使用代理方法来设置高度，否则会出现不可预料的偏差。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  这2个代理方法一定要同时出现，你可以通过某个代理设置返回值为0.01来保证头部或者尾部不存在</div><div class="line"> */</div><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForHeaderInSection:(<span class="built_in">NSInteger</span>)sectio &#123;</div><div class="line">    <span class="comment">// 如果section头部的高度为不存在，一定要返回0.01，不可以返回0，否则达不到预期的效果。可能是系统默认把0当做了任意高度。</span></div><div class="line">    <span class="keyword">return</span> <span class="number">15</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForFooterInSection:(<span class="built_in">NSInteger</span>)section &#123;</div><div class="line">    <span class="comment">// 如果section尾部的高度为不存在，一定要返回0.01，不可以返回0，否则达不到预期的效果。可能是系统默认把0当做了任意高度。</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0.01</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>不论你的tableView的style是<code>UITableViewStyleGrouped</code>还是<code>UITableViewStylePlain</code>，都需要使用代理方法来设置高度，已经做了测试。</strong></p>
<h3 id="控制器切换莫名出现卡顿"><a href="#控制器切换莫名出现卡顿" class="headerlink" title="控制器切换莫名出现卡顿"></a>控制器切换莫名出现卡顿</h3><p>UIKit框架中默认有几个控制器的view是没有背景颜色的，我们在使用的时候一定记得给view的背景颜色赋值，这样有利于渲染。否则会出现控制器切换莫名的卡顿现象。</p>
<ul>
<li>UIWindow</li>
<li>UIViewController</li>
<li>UITabbarController</li>
<li>UICollectionViewConroller</li>
</ul>
<p>而 UITableViewController 的视图view的背景颜色是白色的，不需要主动给背景赋值</p>
<h3 id="如何去掉UITableView多余的分割线"><a href="#如何去掉UITableView多余的分割线" class="headerlink" title="如何去掉UITableView多余的分割线"></a>如何去掉UITableView多余的分割线</h3><p>如果你的UITableView存在分割线，及你没有设置<code>tableView.separatorStyle = UITableViewCellSelectionStyleNone</code>的时候，会显示分割线。如果没有数据，屏幕可见区域依然会显示分割线；如果之存在几条数据，无法占满整个屏幕，屏幕的剩余部分依然会显示分割线，这种情况该如何解决呢？</p>
<p>方案一：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 设置tableFooterView可以去掉多余分割线</span></div><div class="line"><span class="keyword">self</span>.tableView.tableFooterView = [<span class="built_in">UIView</span> new];</div></pre></td></tr></table></figure>
<p>方案二：<em>设置section的头部和尾部为0.01</em></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForHeaderInSection:(<span class="built_in">NSInteger</span>)section &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0.01</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForFooterInSection:(<span class="built_in">NSInteger</span>)section &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0.01</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方案一和方案二都可以解决这个问题，但是依然有点小小的区别。如果使用方案一，那么最后一个cell的底部有分割线；如果使用方案二，那么之后cell和cell之间存在分割线，而不是每个cell的底部有一条分割线。</p>
<h3 id="关于设置UIStatusBar的颜色"><a href="#关于设置UIStatusBar的颜色" class="headerlink" title="关于设置UIStatusBar的颜色"></a>关于设置UIStatusBar的颜色</h3><p>系统提供了2个属性来给我们设置</p>
<h3 id="关于SVN代码冲突的解决"><a href="#关于SVN代码冲突的解决" class="headerlink" title="关于SVN代码冲突的解决"></a>关于SVN代码冲突的解决</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于自定义UIView&quot;&gt;&lt;a href=&quot;#关于自定义UIView&quot; class=&quot;headerlink&quot; title=&quot;关于自定义UIView&quot;&gt;&lt;/a&gt;关于自定义UIView&lt;/h3&gt;&lt;h4 id=&quot;通过xib&quot;&gt;&lt;a href=&quot;#通过xib&quot; class=&quot;headerlink&quot; title=&quot;通过xib&quot;&gt;&lt;/a&gt;通过xib&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;如果其他开发人员不知道你是通过xib创建的cell，或者其他开发人员不小心使用了`initWithFrame`的创建方式，那么你可以通过这样来保证他们通过xib来创建的UIView。
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;instancetype&lt;/span&gt;)initWithFrame:(&lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt;)frame &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [[&lt;span class=&quot;built_in&quot;&gt;NSBundle&lt;/span&gt; mainBundle]loadNibNamed:&lt;span class=&quot;string&quot;&gt;@&quot;YourCustomViewName&quot;&lt;/span&gt; owner:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; options:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;].lastObject;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.frame = frame;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;automaticallyAdjustsScrollViewInsets&quot;&gt;&lt;a href=&quot;#automaticallyAdjustsScrollViewInsets&quot; class=&quot;headerlink&quot; title=&quot;automaticallyAdjustsScrollViewInsets&quot;&gt;&lt;/a&gt;automaticallyAdjustsScrollViewInsets&lt;/h3&gt;&lt;p&gt;这个属性的默认值是YES，如果你的UIScrollView出现莫名的错位，可以检查这个属性是不是设置错了。这个属性告诉当前的控制器是否需要调整他内部滚动视图的内边距（主要的滚动视图也就是UIScrollView或者其子类）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The default value of this property is YES, which lets container view controllers know that they should adjust the scroll view insets of this view controller’s view to account for screen areas consumed by a status bar, search bar, navigation bar, toolbar, or tab bar. Set this property to NO if your view controller implementation manages its own scroll view inset adjustments.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>关于下拉刷新和上拉刷新</title>
    <link href="http://sz8023.github.io/2016/06/15/iOS-20161101%E5%85%B3%E4%BA%8E%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%92%8C%E4%B8%8A%E6%8B%89%E5%88%B7%E6%96%B0/"/>
    <id>http://sz8023.github.io/2016/06/15/iOS-20161101关于下拉刷新和上拉刷新/</id>
    <published>2016-06-15T14:01:03.000Z</published>
    <updated>2016-11-07T13:01:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>移动端开发离不开向后台请求数据，用户往往会通过下拉或上拉来请求数据。而每个App对下拉和上拉处理数据的方式不同。</p>
<p>关于下拉刷新，新浪微博是将请求下来的最新数据拼接到已有数据的前面，并且给出提示有多少条数据更新了，同样上拉刷新是将请求来的数据拼接到已有数据的后面。</p>
<p>而大部分的App采取的方式跟微博不同：一般来说下拉都是请求最新数据，会把之前请求下来的数据给替换掉；而上拉刷新是请求更多数据，会将请求的数据拼接到之前的数据末端。</p>
<p>我们公司也采取了方式二的处理方式，对此我做了一个简单的总结。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>可能涉及到的参数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/** 请求第几页的数据 */</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> pageNum;</div><div class="line"><span class="comment">/** 每个页面显示多少条数据，一般是固定值 */</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> pageSize;</div></pre></td></tr></table></figure>
<p>此处的pageNum用来表示用户请求的是第几页的数据，而pageSize则用来表示每页显示多少条数据；</p>
<a id="more"></a>
<p>有的公司可能只给了一个pageNum的参数来表示用户请求的是第几页的数据，而pageSize由后台来控制返回多少条数据给用户，这样的设计也是可以的；有的公司会要求这2个参数都传递，那么前端就可以通过pageSize来控制每次请求多少条数据，如果不传递这个参数，后台也可能给一个默认的值；</p>
<h3 id="Header和Footer的处理"><a href="#Header和Footer的处理" class="headerlink" title="Header和Footer的处理"></a>Header和Footer的处理</h3><p>此处采用<code>MJRefresh</code>中的block方式做刷新操作。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">self</span>.tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123;</div><div class="line">    [weakSelf pullDownProjectItemListFromNetwork];</div><div class="line">&#125;];</div><div class="line"><span class="keyword">self</span>.tableView.mj_footer = [MJRefreshAutoNormalFooter footerWithRefreshingBlock:^&#123;</div><div class="line">    [weakSelf pullUpProjectItemListFromNetwork];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h3><p>下拉刷新一般会设置<code>pageNum = 1,pageSize = 10</code>当然pageSize如果不传递也是可以的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  下拉加载最新数据</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)pullDownProjectItemListFromNetwork &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.tableView.mj_footer.isRefreshing) &#123;</div><div class="line">        [<span class="keyword">self</span>.tableView.mj_footer endRefreshing];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSString</span> *urlStr = <span class="string">@"manager/itemList.do"</span>;</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *params = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    [params setObject:GetToken forKey:<span class="string">@"token"</span>];</div><div class="line">    [params setValue:@([BD_NSUSERDEFAULTS(IDTYPE) intValue]) forKey:<span class="string">@"userType"</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keyword">self</span>.pageNum = <span class="number">0</span>;</div><div class="line">    [params setObject:<span class="keyword">self</span>.searchBar.text forKey:<span class="string">@"name"</span>];</div><div class="line">    [params setValue:@(<span class="keyword">self</span>.pageSize) forKey:<span class="string">@"pageSize"</span>];</div><div class="line">    [params setValue:@(<span class="keyword">self</span>.pageNum) forKey:<span class="string">@"pageNum"</span>];</div><div class="line">    </div><div class="line">    MJWeakSelf</div><div class="line">    [DCGLNetwork requestMethod:<span class="string">@"GET"</span> URLString:urlStr parameters:params success:^(<span class="built_in">NSDictionary</span> *responseObject) &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         *  1.[mj_header endRefreshing]只需要结束下拉刷新即可，因为之前做了判断，上拉请求根本进不来</div><div class="line">         */</div><div class="line">        [weakSelf.tableView.mj_header endRefreshing];</div><div class="line">        <span class="keyword">if</span> ([[Tools ValueIsNotNull:responseObject[<span class="string">@"code"</span>]] isEqualToString:<span class="string">@"200"</span>])&#123;</div><div class="line">            <span class="comment">/**</span></div><div class="line">             *  1.此处先移除之前的所有数据，然后添加新的数据，这样防止后台返回空数据的时候</div><div class="line">             *    前端做刷新操作的时候可以显示正确的结果，无数据</div><div class="line">             */</div><div class="line">            [weakSelf.dataArr removeAllObjects];</div><div class="line">            <span class="built_in">NSArray</span> *resultData = responseObject[<span class="string">@"data"</span>][<span class="string">@"data"</span>][<span class="string">@"rows"</span>];</div><div class="line">            <span class="keyword">if</span> ([Tools ValueIsNotNull:resultData] &amp;&amp; resultData.count != <span class="number">0</span>) &#123;</div><div class="line">                weakSelf.dataArr = [DCProjectModel mj_objectArrayWithKeyValuesArray:resultData];</div><div class="line">            &#125;</div><div class="line">            [weakSelf.tableView reloadData];</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSString</span> *error = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,responseObject[<span class="string">@"data"</span>][<span class="string">@"error"</span>]];</div><div class="line">            [Tools showErrorHUDViewAtView:<span class="keyword">self</span>.view WithTitle:error];</div><div class="line">        &#125;</div><div class="line">    &#125; fail:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">        [weakSelf.tableView.mj_header endRefreshing];</div><div class="line">        [Tools showErrorHUDViewAtView:<span class="keyword">self</span>.view WithTitle:<span class="string">@"网络开小差了"</span>];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了防止用户同一时刻多次刷新，也有不同的处理方式，我们公司采用了添加加载进度的提示，这样当数据没有请求回来的时候，用户无法再次请求数据；当然你也可以通过下面判断方式来处理</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.tableView.mj_header.isRefreshing || <span class="keyword">self</span>.tableView.mj_footer.isRefreshing) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="上拉请求更多数据"><a href="#上拉请求更多数据" class="headerlink" title="上拉请求更多数据"></a>上拉请求更多数据</h3><p>上拉请求稍微复杂了一点，主要集中在对pageNum的操作和对后台返回数据的处理，此处采取这样的处理方式。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  上拉加载更多数据</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)pullUpProjectItemListFromNetwork &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  1.如果mj_header.isRefreshing是YES，那么上次的下拉请求还没有处理完毕，</div><div class="line">     *    用户就开始了下次的下拉请求，所以要return。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.tableView.mj_header.isRefreshing) &#123;</div><div class="line">        [<span class="keyword">self</span>.tableView.mj_header endRefreshing];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSString</span> *urlStr = <span class="string">@"manager/itemList.do"</span>;</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *params = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    [params setObject:GetToken forKey:<span class="string">@"token"</span>];</div><div class="line">    [params setValue:@([BD_NSUSERDEFAULTS(IDTYPE) intValue]) forKey:<span class="string">@"userType"</span>];</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  1.设置临时变量tempPageNum是比较简单的处理方式，防止网络不佳数据请求不下来的时候，</div><div class="line">     *    前端依然对pageNum做了plusplus的操作</div><div class="line">     */</div><div class="line">    <span class="built_in">NSInteger</span> tempPageNum  = <span class="keyword">self</span>.pageNum + <span class="number">1</span>;</div><div class="line">    [params setObject:<span class="keyword">self</span>.searchBar.text forKey:<span class="string">@"name"</span>];</div><div class="line">    [params setValue:@(<span class="keyword">self</span>.pageSize) forKey:<span class="string">@"pageSize"</span>];</div><div class="line">    [params setValue:@(tempPageNum) forKey:<span class="string">@"pageNum"</span>];</div><div class="line">    </div><div class="line">    MJWeakSelf</div><div class="line">    [DCGLNetwork requestMethod:<span class="string">@"GET"</span> URLString:urlStr parameters:params success:^(<span class="built_in">NSDictionary</span> *responseObject) &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         *  1.[mj_footer endRefreshing]只需要结束上拉刷新即可，因为之前做了判断，下拉请求根本进不来</div><div class="line">         */</div><div class="line">        [weakSelf.tableView.mj_footer endRefreshing];</div><div class="line">        <span class="keyword">if</span> ([[Tools ValueIsNotNull:responseObject[<span class="string">@"code"</span>]] isEqualToString:<span class="string">@"200"</span>])&#123;</div><div class="line">            <span class="built_in">NSArray</span> *resultData = responseObject[<span class="string">@"data"</span>][<span class="string">@"data"</span>][<span class="string">@"rows"</span>];</div><div class="line">            <span class="keyword">if</span> ([Tools ValueIsNotNull:resultData]) &#123;</div><div class="line">                <span class="keyword">if</span> (resultData.count != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="built_in">NSArray</span> *tempArr = [DCProjectModel mj_objectArrayWithKeyValuesArray:resultData];</div><div class="line">                    [weakSelf.dataArr addObjectsFromArray:tempArr];</div><div class="line">                    </div><div class="line">                    <span class="comment">/**</span></div><div class="line">                     *  1.上拉请求结果的可能情况要么是有数据，要么是无数据，只有当有数据的情况再做赋值操作，</div><div class="line">                     *     因为如果没有数据依然做了赋值操作，那么下次的上拉pageNum的值就可能被无缘无故做了+1操作。</div><div class="line">                     *  2.当有数据的时候，如果0 &lt; resultData.count &lt; pageSize，依然要对pageNum赋值，因为如果用户再次上拉的时候，</div><div class="line">                     *     如果没有赋值，那么请求的的是重复的数据。</div><div class="line">                     */</div><div class="line">                    <span class="keyword">self</span>.pageNum = tempPageNum;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (resultData.count &lt; weakSelf.pageSize) &#123;</div><div class="line">                    <span class="comment">/**</span></div><div class="line">                     *  1.当请求的数据为0条的时候，做出判断</div><div class="line">                     */</div><div class="line">                    [weakSelf.tableView.mj_footer endRefreshingWithNoMoreData];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            [weakSelf.tableView reloadData];</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSString</span> *error = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,responseObject[<span class="string">@"data"</span>][<span class="string">@"error"</span>]];</div><div class="line">            [Tools showErrorHUDViewAtView:<span class="keyword">self</span>.view WithTitle:error];</div><div class="line">        &#125;</div><div class="line">    &#125; fail:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">        [weakSelf.tableView.mj_footer endRefreshing];</div><div class="line">        [Tools showErrorHUDViewAtView:<span class="keyword">self</span>.view WithTitle:<span class="string">@"网络开小差了"</span>];</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先通过定义一个临时变量的<code>tempPageNum = pageNum + 1</code>，当用户数据请求下来的时候在做<code>pageNum = tempPageNum</code>的操作，防止用户上拉的时候数据请求不下来的情况，</p>
<h3 id="关于加载进度"><a href="#关于加载进度" class="headerlink" title="关于加载进度"></a>关于加载进度</h3><p>公司部分刷新也采用了添加加载进度的提示方式，如果是这个方式处理起来就比较简单了。同时也鼓励使用这种方式来处理刷新情况</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  下拉加载最新数据</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)pullDownProjectItemListFromNetwork &#123;</div><div class="line">    <span class="built_in">NSString</span> *urlStr = <span class="string">@"manager/itemList.do"</span>;</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *params = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    [params setObject:GetToken forKey:<span class="string">@"token"</span>];</div><div class="line">    [params setValue:@([BD_NSUSERDEFAULTS(IDTYPE) intValue]) forKey:<span class="string">@"userType"</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.pageNum = <span class="number">1</span>;</div><div class="line">    [params setObject:<span class="keyword">self</span>.searchBar.text forKey:<span class="string">@"name"</span>];</div><div class="line">    [params setValue:@(<span class="keyword">self</span>.pageSize) forKey:<span class="string">@"pageSize"</span>];</div><div class="line">    [params setValue:@(<span class="keyword">self</span>.pageNum) forKey:<span class="string">@"pageNum"</span>];</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  此处添加到tableView上面不是window上面这样导航栏就可以点击了</div><div class="line">     */</div><div class="line">    [Tools showHUDAddedTo:<span class="keyword">self</span>.tableView];</div><div class="line">    </div><div class="line">    MJWeakSelf</div><div class="line">    [DCGLNetwork requestMethod:<span class="string">@"GET"</span> URLString:urlStr parameters:params success:^(<span class="built_in">NSDictionary</span> *responseObject) &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         *  1.结束下拉刷新</div><div class="line">         */</div><div class="line">        [weakSelf.tableView.mj_header endRefreshing];</div><div class="line">        [Tools hideAllHUDsForView:weakSelf.tableView];</div><div class="line">        <span class="keyword">if</span> ([[Tools ValueIsNotNull:responseObject[<span class="string">@"code"</span>]] isEqualToString:<span class="string">@"200"</span>])&#123;</div><div class="line">            <span class="comment">/**</span></div><div class="line">             *  1.此处先移除之前的所有数据，然后添加新的数据，这样防止后台返回空数据的时候</div><div class="line">             *    前端做刷新操作的时候可以显示正确的结果，无数据</div><div class="line">             */</div><div class="line">            [weakSelf.dataArr removeAllObjects];</div><div class="line">            <span class="built_in">NSArray</span> *resultData = responseObject[<span class="string">@"data"</span>][<span class="string">@"data"</span>][<span class="string">@"rows"</span>];</div><div class="line">            <span class="keyword">if</span> ([Tools ValueIsNotNull:resultData] &amp;&amp; resultData.count != <span class="number">0</span>) &#123;</div><div class="line">                weakSelf.dataArr = [DCProjectModel mj_objectArrayWithKeyValuesArray:resultData];</div><div class="line">            &#125;</div><div class="line">            [weakSelf.tableView reloadData];</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSString</span> *error = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,responseObject[<span class="string">@"data"</span>][<span class="string">@"error"</span>]];</div><div class="line">            [Tools showErrorHUDViewAtView:<span class="keyword">self</span>.view WithTitle:error];</div><div class="line">        &#125;</div><div class="line">    &#125; fail:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">        [weakSelf.tableView.mj_header endRefreshing];</div><div class="line">        [Tools hideAllHUDsForView:weakSelf.tableView];</div><div class="line">        [Tools showErrorHUDViewAtView:<span class="keyword">self</span>.view WithTitle:<span class="string">@"网络开小差了"</span>];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关于占位图片"><a href="#关于占位图片" class="headerlink" title="关于占位图片"></a>关于占位图片</h3><ul>
<li>网络连接错误显示占位图片</li>
<li>后台返回数据为空显示占位图片</li>
</ul>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>对于刷新部分很多公司更倾向于使用加载进度的提示方式，因为这样处理起来比较简单；而如果不使用加载进的提示方式，有很多需要思考的地方，比如用户在刷新的过程中可能对里面Cell中的数据做操作，比如点击当前cell在本页面请求数据，点击cell里面的按钮跳转到其他页面等等，而其他页面刚进入的时候还有网络请求的处理，那么这个页面的网络请求如何处理，当然可以在<code>dealloc</code>方法中将网络请求给关闭掉……</p>
<ul>
<li>返回数据的判断，很多公司都存在这样的情况移动设备上显示“null”给用户，其实这样也挺好，至少有可以展示的内容，时间久了，用户或许也都知道了这个是后台返回数据的为空造成的。</li>
<li>返回数据如果转换成对象之后，一旦对象为空，或者为null，<null>之类的，当再次调用对象的属性或者方法的时候是否会崩溃，导致程序退出的问题。</null></li>
<li>关于网络请求，如果存在界面跳转的请求，如何处理上个页面还未请求下拉的数据，不做处理会奔溃吗？需要验证。</li>
</ul>
<p>&lt;未完待续&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动端开发离不开向后台请求数据，用户往往会通过下拉或上拉来请求数据。而每个App对下拉和上拉处理数据的方式不同。&lt;/p&gt;
&lt;p&gt;关于下拉刷新，新浪微博是将请求下来的最新数据拼接到已有数据的前面，并且给出提示有多少条数据更新了，同样上拉刷新是将请求来的数据拼接到已有数据的后面。&lt;/p&gt;
&lt;p&gt;而大部分的App采取的方式跟微博不同：一般来说下拉都是请求最新数据，会把之前请求下来的数据给替换掉；而上拉刷新是请求更多数据，会将请求的数据拼接到之前的数据末端。&lt;/p&gt;
&lt;p&gt;我们公司也采取了方式二的处理方式，对此我做了一个简单的总结。&lt;/p&gt;
&lt;h3 id=&quot;参数&quot;&gt;&lt;a href=&quot;#参数&quot; class=&quot;headerlink&quot; title=&quot;参数&quot;&gt;&lt;/a&gt;参数&lt;/h3&gt;&lt;p&gt;可能涉及到的参数：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** 请求第几页的数据 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; pageNum;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** 每个页面显示多少条数据，一般是固定值 */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; pageSize;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此处的pageNum用来表示用户请求的是第几页的数据，而pageSize则用来表示每页显示多少条数据；&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>使用AutoLayout布局自定义UITableViewCell</title>
    <link href="http://sz8023.github.io/2016/05/27/iOS-20161027%E4%BD%BF%E7%94%A8AutoLayout%E5%B8%83%E5%B1%80%E8%87%AA%E5%AE%9A%E4%B9%89UITableViewCell/"/>
    <id>http://sz8023.github.io/2016/05/27/iOS-20161027使用AutoLayout布局自定义UITableViewCell/</id>
    <published>2016-05-27T14:43:45.000Z</published>
    <updated>2016-10-27T14:57:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>此处首先感谢<code>峰哥</code>的指导，不要问我峰哥何许人也，请Google东半球最帅男人。不扯淡了，进入正题……</p>
<p>### </p>
<p>还是说几句吧！真心话，一直是<code>峰哥</code>在给我细心的指导，不厌其烦的给我讲解他项目中遇到的各种问题，而我真的是受益匪浅。我觉得自己总是接受的太多给予的太少，有愧于峰哥。觉得峰哥唯一的收益之处就是有个像我这样的学生认真的倾听他探索真理的过程，可以发现自己的理解是否到位，然后一起讨论一起进步</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此处首先感谢&lt;code&gt;峰哥&lt;/code&gt;的指导，不要问我峰哥何许人也，请Google东半球最帅男人。不扯淡了，进入正题……&lt;/p&gt;
&lt;p&gt;### &lt;/p&gt;
&lt;p&gt;还是说几句吧！真心话，一直是&lt;code&gt;峰哥&lt;/code&gt;在给我细心的指导，不厌其烦的给我讲解他项目中遇到的各
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>关于适配的总结</title>
    <link href="http://sz8023.github.io/2016/05/14/iOS-20160928%E5%85%B3%E4%BA%8E%E9%80%82%E9%85%8D%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://sz8023.github.io/2016/05/14/iOS-20160928关于适配的总结/</id>
    <published>2016-05-14T06:49:15.000Z</published>
    <updated>2016-09-30T07:31:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中，比较常用的适配模式就是xib，storyboard和纯代码的方式。而纯代码方式我使用比较多的是第三方库<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">Masonry</a>。但是对于这些概念一直比较模糊，比如发展历史，使用区别，使用频率，在什么时候选用什么样的布局方式等等。</p>
<table>
<thead>
<tr>
<th style="text-align:center">设备</th>
<th style="text-align:center">适配技术</th>
<th style="text-align:center">优缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">iPhone4/4s</td>
<td style="text-align:center">通过frame计算</td>
<td style="text-align:center">设备比较单一，计算量比较小</td>
</tr>
<tr>
<td style="text-align:center">iPad</td>
<td style="text-align:center">AutoResizing</td>
<td style="text-align:center">只可以实现父子控件之间的约束</td>
</tr>
<tr>
<td style="text-align:center">iPhone5/5s</td>
<td style="text-align:center">AutoLayout</td>
<td style="text-align:center">既可以实现父子控件约束，又可以实现同级控件之间的约束</td>
</tr>
<tr>
<td style="text-align:center">iPhone6/6s</td>
<td style="text-align:center">SizeClass</td>
<td style="text-align:center">可以给不同设备设置不同的约束，AutoLayout可以给不同设备设置同一                              套约束</td>
</tr>
</tbody>
</table>
<p>通常这几种技术当中，AutoResizing的工作完全可以由AutoLayout来代替，所以开发中几乎不再考虑。对于iPhone的不同设备采用同一套布局方式是很多公司都会采用的方式，如果再去考虑iPad的话开发工作是比较繁琐的，所以AutoLayout的使用频率是最高的。倘若真的要考虑同时适配iPhone和iPad的话，那么肯定要采用不同的布局方式，因为iPad的屏幕宽高比跟iPhone相差还是很大的，这个时候SizeClass就是你的最佳选择。</p>
<p>这个时候我觉得还需要把计算frame和AutoLayout拿出来说一下，毕竟很多人可能会像我一样在日常的Demo中会通过计算frame的方式最快的查看想要的结果。</p>
<ul>
<li>通过frame计算的方式实现方式比较简单，远比NSLayoutConstraints语法简单</li>
<li>相对布局frame可以通过CGRectGetMaxY或者CGRectGetMaxX等来实现相对布局。</li>
<li>重点是：通过frame和AutoLayout其他方式上的区别还在探索当中……</li>
</ul>
<h4 id="关于适配"><a href="#关于适配" class="headerlink" title="关于适配"></a>关于适配</h4><p>跟设备有关的会涉及到设备和系统，如今iPhone有很多不同设备，比如iPhone5,iPhone6等；同一个种设备又可能存在不同的系统，比如iOS9.0，iOS10.0等。</p>
<p>如何区分不同设备，开发中喜欢使用下面的方式，由于iPhone7跟iPhone6的尺寸没有发生变化，所以这边值需要对不同的设备尺寸有个区分就可以了。</p>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#define IS_IPHONE4 (([[UIScreen mainScreen] bounds].size.height == 480) ? YES : NO)</span></div><div class="line"><span class="meta">#define IS_IPHONE5 (([[UIScreen mainScreen] bounds].size.height == 568) ? YES : NO)</span></div><div class="line"><span class="meta">#define IS_IPhone6 (([[UIScreen mainScreen] bounds].size.height == 667) ? YES : NO)</span></div><div class="line"><span class="meta">#define IOS_IPhone6plusS (([[UIScreen mainScreen] bounds].size.height = 736) ? YES : NO)</span></div></pre></td></tr></table></figure>
<p>那么在什么地方经常会用到这些宏呢？</p>
<ul>
<li>配置启动图片</li>
<li>设置UICollectionView中cell之间的spacing</li>
<li>……</li>
</ul>
<p>设备系统的判断，也可以通过宏定义的方式来实现，下面的代码可用于系统的判断</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#define IS_OS_8_OR_LATER    ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0)</span></div><div class="line"><span class="meta">#define IS_OS_9_OR_LATER    ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 9.0)</span></div><div class="line"><span class="meta">#define IS_OS_10_OR_LATER    ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 10.0)</span></div></pre></td></tr></table></figure>
<p>或者通过这样判断也可以达到相同的效果。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//判断系统版本</span></div><div class="line"><span class="meta">#define SYSTEM_VERSION_EQUAL_TO(v)                  ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedSame)</span></div><div class="line"><span class="meta">#define SYSTEM_VERSION_GREATER_THAN(v)              ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedDescending)</span></div><div class="line"><span class="meta">#define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v)  ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)</span></div><div class="line"><span class="meta">#define SYSTEM_VERSION_LESS_THAN(v)                 ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)</span></div><div class="line"><span class="meta">#define SYSTEM_VERSION_LESS_THAN_OR_EQUAL_TO(v)     ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedDescending)</span></div></pre></td></tr></table></figure>
<p>同样，什么地方需要用来判断系统？有些功能低版本的没有！</p>
<ul>
<li>地图需要请求权限才可以，并且需要配合info.plist，这个在iOS8.0以后</li>
<li>字体设置，比如“PingFangSC-Regular”字体iOS9.0之后才可以使用</li>
<li>3DTouch功能只有iOS9.0之后才有</li>
<li>……</li>
</ul>
<h4 id="关于Masonry"><a href="#关于Masonry" class="headerlink" title="关于Masonry"></a>关于Masonry</h4><p>开发中最长使用的是Masonry，关于这个可以参考<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">Masonry官网</a></p>
<p>关于使用方式可以参考官方的Demo。官方的Demo中已经给出了很好例子说明。</p>
<table>
<thead>
<tr>
<th>Basic</th>
<th>基础用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Update Constraints</td>
<td>更新约束</td>
</tr>
<tr>
<td>Remark Constraints</td>
<td>标记约束</td>
</tr>
<tr>
<td>Using Constraints</td>
<td>使用约束</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常开发中，比较常用的适配模式就是xib，storyboard和纯代码的方式。而纯代码方式我使用比较多的是第三方库&lt;a href=&quot;https://github.com/SnapKit/Masonry&quot;&gt;Masonry&lt;/a&gt;。但是对于这些概念一直比较模糊，比如发展历史，使用区别，使用频率，在什么时候选用什么样的布局方式等等。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;设备&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;适配技术&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;优缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;iPhone4/4s&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;通过frame计算&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;设备比较单一，计算量比较小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;iPad&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;AutoResizing&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;只可以实现父子控件之间的约束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;iPhone5/5s&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;AutoLayout&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;既可以实现父子控件约束，又可以实现同级控件之间的约束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;iPhone6/6s&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;SizeClass&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;可以给不同设备设置不同的约束，AutoLayout可以给不同设备设置同一                              套约束&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;通常这几种技术当中，AutoResizing的工作完全可以由AutoLayout来代替，所以开发中几乎不再考虑。对于iPhone的不同设备采用同一套布局方式是很多公司都会采用的方式，如果再去考虑iPad的话开发工作是比较繁琐的，所以AutoLayout的使用频率是最高的。倘若真的要考虑同时适配iPhone和iPad的话，那么肯定要采用不同的布局方式，因为iPad的屏幕宽高比跟iPhone相差还是很大的，这个时候SizeClass就是你的最佳选择。&lt;/p&gt;
&lt;p&gt;这个时候我觉得还需要把计算frame和AutoLayout拿出来说一下，毕竟很多人可能会像我一样在日常的Demo中会通过计算frame的方式最快的查看想要的结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过frame计算的方式实现方式比较简单，远比NSLayoutConstraints语法简单&lt;/li&gt;
&lt;li&gt;相对布局frame可以通过CGRectGetMaxY或者CGRectGetMaxX等来实现相对布局。&lt;/li&gt;
&lt;li&gt;重点是：通过frame和AutoLayout其他方式上的区别还在探索当中……&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;关于适配&quot;&gt;&lt;a href=&quot;#关于适配&quot; class=&quot;headerlink&quot; title=&quot;关于适配&quot;&gt;&lt;/a&gt;关于适配&lt;/h4&gt;&lt;p&gt;跟设备有关的会涉及到设备和系统，如今iPhone有很多不同设备，比如iPhone5,iPhone6等；同一个种设备又可能存在不同的系统，比如iOS9.0，iOS10.0等。&lt;/p&gt;
&lt;p&gt;如何区分不同设备，开发中喜欢使用下面的方式，由于iPhone7跟iPhone6的尺寸没有发生变化，所以这边值需要对不同的设备尺寸有个区分就可以了。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>使用AutoLayout布局自定义UIView</title>
    <link href="http://sz8023.github.io/2016/04/27/iOS-20161027%E4%BD%BF%E7%94%A8AutoLayout%E5%B8%83%E5%B1%80%E8%87%AA%E5%AE%9A%E4%B9%89UIView/"/>
    <id>http://sz8023.github.io/2016/04/27/iOS-20161027使用AutoLayout布局自定义UIView/</id>
    <published>2016-04-27T13:49:24.000Z</published>
    <updated>2016-10-28T06:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>在项目开发中偶尔也会遇见这样的需求，需要你自定义一个<code>UIView</code>。这个自定义的UIView需要根据内部的UILabel来调整内容。当然不论这个UIView是不是自定义的都无所谓，只要需要你根据内部的UILabel来调整父视图的frame的时候都可以采用这种方式来布局。</p>
<p>此处的举例采用XIB布局方式</p>
<h3 id="自定义的FGView"><a href="#自定义的FGView" class="headerlink" title="自定义的FGView"></a>自定义的FGView</h3><p>自定义一个继承自UIView的<code>FGView</code>并且创建对应的FGView.xib，然后绑定。顶部图片设置上左右约束然后高度固定，中间的UILabel设置上左右约束，然后numberoflines=0，同样底部的UILabel也设置上左右约束，然后numberoflines=0。此处千万不要设置底部的约束，否则xib会报错。（此处做一个假设，可能是因为UIView需要先确定父视图的frame，然后在确定子视图的frame；这个跟继承UIScrollView的视图不同，继承自UIScrollView的视图需要先确定内部的contentSize，然后是确定bounds，contentInset，contentOffset等）</p>
<p><img src="20161027使用AutoLayout布局自定义UIView/FGView.png" alt="FGView"></p>
<h3 id="处理FGView的数据"><a href="#处理FGView的数据" class="headerlink" title="处理FGView的数据"></a>处理FGView的数据</h3><p>将FGView.xib和FGView类绑定之后，然后拖出对应的UILabel，</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *fgLBL;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *szLBL;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>在FGView.h文件中添加数据源，此处只是简单设置。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)  <span class="built_in">NSDictionary</span> *fgDict;</div></pre></td></tr></table></figure>
<p>我们需要重写fgDict的set方法来给2个标签赋值</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setFgDict:(<span class="built_in">NSDictionary</span> *)fgDict &#123;</div><div class="line">    _fgDict = fgDict;</div><div class="line">    <span class="keyword">self</span>.fgLBL.text = fgDict[<span class="string">@"fg"</span>];</div><div class="line">    <span class="keyword">self</span>.szLBL.text = fgDict[<span class="string">@"sz"</span>];</div><div class="line">    [<span class="keyword">self</span> setNeedsLayout];</div><div class="line">    [<span class="keyword">self</span> layoutIfNeeded];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们在这个方法中重新布局</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</div><div class="line">    [<span class="keyword">super</span> layoutSubviews];</div><div class="line">    <span class="built_in">CGFloat</span> y = <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span>.szLBL.frame);</div><div class="line">    <span class="built_in">CGRect</span> frame = <span class="keyword">self</span>.frame;</div><div class="line">    <span class="keyword">self</span>.frame = <span class="built_in">CGRectMake</span>(frame.origin.x, frame.origin.y, frame.size.width, y+<span class="number">20</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时布局完美实现。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>以下是测试代码，</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    FGView *fgView = [[[<span class="built_in">NSBundle</span> mainBundle] loadNibNamed:<span class="string">@"FGView"</span> owner:<span class="keyword">self</span> options:<span class="literal">nil</span>] lastObject];</div><div class="line">    fgView.frame = <span class="keyword">self</span>.view.bounds;</div><div class="line">    [<span class="keyword">self</span>.view addSubview:fgView];</div><div class="line">    <span class="built_in">NSDictionary</span> *dic = @&#123;<span class="string">@"fg"</span>:<span class="string">@"月落乌啼霜满天，江枫渔火对愁眠。"</span>,</div><div class="line">                          <span class="string">@"sz"</span>:<span class="string">@"姑苏城外寒山寺，夜半钟声到客船。"</span>&#125;;</div><div class="line">    fgView.fgDict = dic;</div><div class="line">    <span class="keyword">self</span>.fgView  = fgView;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    <span class="built_in">NSDictionary</span> *dic = @&#123;<span class="string">@"fg"</span>:<span class="string">@"床前明月光，疑是地上霜。举头望明月，低头思故乡。床前明月光，疑是地上霜。举头望明月，低头思故乡。床前明月光，疑是地上霜。举头望明月，低头思故乡。床前明月光，疑是地上霜。举头望明月，低头思故乡。"</span>,</div><div class="line">                          <span class="string">@"sz"</span>:<span class="string">@"白日依山尽，黄河入海流。欲穷千里目，更上一层楼。白日依山尽，黄河入海流。欲穷千里目，更上一层楼。白日依山尽，黄河入海流。欲穷千里目，更上一层楼。白日依山尽，黄河入海流。欲穷千里目，更上一层楼。"</span>&#125;;</div><div class="line">    <span class="keyword">self</span>.fgView.fgDict = dic;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>为何需要在<code>layoutSubviews</code>中设置布局。</p>
<ul>
<li>不可以将修改布局放在<code>-(void)setDict:(NSDictionary *)dict</code>方法中，如果在这个方法中，那么如果FGView的frame改变的话，这个方法不会调用，无法做到动态调用布局，所以需要放在frame中。</li>
</ul>
<p>建议在调用<code>[self layoutIfNeeded]</code>方法之前调用<code>[self setNeedsLayout]</code>。</p>
<p>关于<code>layoutSubviews</code>在什么时候调用请参考我的文章，里面有详细的描述<a href="">自定义控件</a>;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目开发中偶尔也会遇见这样的需求，需要你自定义一个&lt;code&gt;UIView&lt;/code&gt;。这个自定义的UIView需要根据内部的UILabel来调整内容。当然不论这个UIView是不是自定义的都无所谓，只要需要你根据内部的UILabel来调整父视图的frame的时候都可以采用这种方式来布局。&lt;/p&gt;
&lt;p&gt;此处的举例采用XIB布局方式&lt;/p&gt;
&lt;h3 id=&quot;自定义的FGView&quot;&gt;&lt;a href=&quot;#自定义的FGView&quot; class=&quot;headerlink&quot; title=&quot;自定义的FGView&quot;&gt;&lt;/a&gt;自定义的FGView&lt;/h3&gt;&lt;p&gt;自定义一个继承自UIView的&lt;code&gt;FGView&lt;/code&gt;并且创建对应的FGView.xib，然后绑定。顶部图片设置上左右约束然后高度固定，中间的UILabel设置上左右约束，然后numberoflines=0，同样底部的UILabel也设置上左右约束，然后numberoflines=0。此处千万不要设置底部的约束，否则xib会报错。（此处做一个假设，可能是因为UIView需要先确定父视图的frame，然后在确定子视图的frame；这个跟继承UIScrollView的视图不同，继承自UIScrollView的视图需要先确定内部的contentSize，然后是确定bounds，contentInset，contentOffset等）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;20161027使用AutoLayout布局自定义UIView/FGView.png&quot; alt=&quot;FGView&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;处理FGView的数据&quot;&gt;&lt;a href=&quot;#处理FGView的数据&quot; class=&quot;headerlink&quot; title=&quot;处理FGView的数据&quot;&gt;&lt;/a&gt;处理FGView的数据&lt;/h3&gt;&lt;p&gt;将FGView.xib和FGView类绑定之后，然后拖出对应的UILabel，&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;IBOutlet&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;UILabel&lt;/span&gt; *fgLBL;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;IBOutlet&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;UILabel&lt;/span&gt; *szLBL;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>CornerStone使用小技巧</title>
    <link href="http://sz8023.github.io/2016/04/23/iOS-20160923CornerStone%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://sz8023.github.io/2016/04/23/iOS-20160923CornerStone使用小技巧/</id>
    <published>2016-04-23T07:05:11.000Z</published>
    <updated>2016-12-12T14:34:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用CornerStone工具的时候有一些常用的小技巧，当然这些小技巧可能很多人都知道，但是对于刚刚接触的小伙伴来说可能就不一样了。所以，记录了一下给自己也给大家做一个参考。</p>
<h3 id="关于忽略文件的问题"><a href="#关于忽略文件的问题" class="headerlink" title="关于忽略文件的问题"></a>关于忽略文件的问题</h3><p>在项目初始化创建的时候可能会需要处理<code>.xcuserdatad</code>文件的问题，这个问题我也在网上搜索了一些答案，但是总感觉过程太过繁琐。</p>
<p>前几天在跟朋友峰哥讨论“如何提交.a文件到SVN”的时候，在峰哥指导下，知道了通过如何配置CornerStone来解决这个<code>.a</code>文件的提交问题。同样的，我觉得对于<code>.xcuserdatad</code>文件也可以用同样的问题来解决。</p>
<p>通过打开CornerStone的<strong>CornerStone</strong>》<strong>Preferences..</strong>》，然后点击<strong>Subversion</strong>选项卡，再选择<strong>General</strong>，可以发现有个<strong>Global Ignores</strong>。</p>
<p><img src="../images/CornerStone.png" alt="CornerStone"></p>
<p>如果你不想使用系统默认的忽略文件，那么就不要勾选<strong>User default global ignores</strong>。然后在这边你可以去掉或者添加你想要忽略的文件。</p>
<h3 id="对于Xcode如何处理"><a href="#对于Xcode如何处理" class="headerlink" title="对于Xcode如何处理"></a>对于Xcode如何处理</h3><p>之前没有使用CornerStone的时候，一直使用的是Xcode自带的SVN版本管理，对于<code>.a</code>文件同样会要相同的问题，当时的解决思路是通过命令的方式在终端将<code>.a</code>文件提交到SVN。但是可不可以通过配置的方式解决这个问题，还有待进一步研究。</p>
<a id="more"></a>
<h3 id="其他的一些细节处理"><a href="#其他的一些细节处理" class="headerlink" title="其他的一些细节处理"></a>其他的一些细节处理</h3><ul>
<li>在WORKING COPY对应的工作控件创建文件夹或者文件，CornerStone可以自动识别，并且会在客户端有一个<code>?</code>显示，告诉程序员有一个文件或者文件夹没有被添加到本地的SVN，如果你没有选择添加，那么在提交的时候（及当commit的时候），会有提示，告诉你有文件没有添加到本地的SVN，这个时候你可以选择<code>Add to Working Copy</code>将文件夹或者文件添加到本地的SVN。</li>
</ul>
<p><img src="../images/CornerStone_commit.png" width="640" alt="CornerStone_commit"></p>
<ul>
<li><p>如果你是在Xcode中通过New Group创建的文件夹，那么这个文件夹只是虚拟的文件夹，之后通过右键Finder创建的文件夹才是实实在在的文件夹，然后你可以将这个文件Import到项目中，或者拖动到项目中，这个时候CornerStone依然可以会提示你文件或者文件夹是否添加到本地的SVN当中。可以通过底部的工具栏<code>Add</code>将文件添加到本地的SVN中。</p>
</li>
<li><p>你创建的文件或者文件夹有在commit的时候有的是有提示的，可是有的并没有（我遇到的这种情况，比如你通过pod方式导入一个第三方库的，第三方库中的文件可能有的就不会提示你添加到SVN中，这个时候你就需要自己通过手动来添加这种情况了）</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用CornerStone工具的时候有一些常用的小技巧，当然这些小技巧可能很多人都知道，但是对于刚刚接触的小伙伴来说可能就不一样了。所以，记录了一下给自己也给大家做一个参考。&lt;/p&gt;
&lt;h3 id=&quot;关于忽略文件的问题&quot;&gt;&lt;a href=&quot;#关于忽略文件的问题&quot; class=&quot;headerlink&quot; title=&quot;关于忽略文件的问题&quot;&gt;&lt;/a&gt;关于忽略文件的问题&lt;/h3&gt;&lt;p&gt;在项目初始化创建的时候可能会需要处理&lt;code&gt;.xcuserdatad&lt;/code&gt;文件的问题，这个问题我也在网上搜索了一些答案，但是总感觉过程太过繁琐。&lt;/p&gt;
&lt;p&gt;前几天在跟朋友峰哥讨论“如何提交.a文件到SVN”的时候，在峰哥指导下，知道了通过如何配置CornerStone来解决这个&lt;code&gt;.a&lt;/code&gt;文件的提交问题。同样的，我觉得对于&lt;code&gt;.xcuserdatad&lt;/code&gt;文件也可以用同样的问题来解决。&lt;/p&gt;
&lt;p&gt;通过打开CornerStone的&lt;strong&gt;CornerStone&lt;/strong&gt;》&lt;strong&gt;Preferences..&lt;/strong&gt;》，然后点击&lt;strong&gt;Subversion&lt;/strong&gt;选项卡，再选择&lt;strong&gt;General&lt;/strong&gt;，可以发现有个&lt;strong&gt;Global Ignores&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/CornerStone.png&quot; alt=&quot;CornerStone&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你不想使用系统默认的忽略文件，那么就不要勾选&lt;strong&gt;User default global ignores&lt;/strong&gt;。然后在这边你可以去掉或者添加你想要忽略的文件。&lt;/p&gt;
&lt;h3 id=&quot;对于Xcode如何处理&quot;&gt;&lt;a href=&quot;#对于Xcode如何处理&quot; class=&quot;headerlink&quot; title=&quot;对于Xcode如何处理&quot;&gt;&lt;/a&gt;对于Xcode如何处理&lt;/h3&gt;&lt;p&gt;之前没有使用CornerStone的时候，一直使用的是Xcode自带的SVN版本管理，对于&lt;code&gt;.a&lt;/code&gt;文件同样会要相同的问题，当时的解决思路是通过命令的方式在终端将&lt;code&gt;.a&lt;/code&gt;文件提交到SVN。但是可不可以通过配置的方式解决这个问题，还有待进一步研究。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>开发杂烩</title>
    <link href="http://sz8023.github.io/2016/03/16/iOS-%E5%BC%80%E5%8F%91%E6%9D%82%E7%83%A9/"/>
    <id>http://sz8023.github.io/2016/03/16/iOS-开发杂烩/</id>
    <published>2016-03-15T23:53:10.000Z</published>
    <updated>2016-09-22T08:26:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录一些开发中常用的技巧。比如常用的常量文件，宏定义文件，什么时候创建分类，什么时候使用继承，什么时候使用代理封装第三方库（哪些第三方库需要封装，如何封装）等等。</p>
<h3 id="关于常量"><a href="#关于常量" class="headerlink" title="关于常量"></a>关于常量</h3><p>很显然不变的量就是常量，比较常用的地方就是整形，浮点型，字符串等。这个时候不建议使用#define来定义。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> weight = <span class="number">70</span>;<span class="comment">// 定义一个整形常量</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> height = <span class="number">166.0</span>;<span class="comment">// 定义一个浮点型常量</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> <span class="keyword">const</span> *city = <span class="string">@"上海"</span>;<span class="comment">// 定义一个常量字符串</span></div></pre></td></tr></table></figure>
<h3 id="关于宏定义"><a href="#关于宏定义" class="headerlink" title="关于宏定义"></a>关于宏定义</h3><p>宏定义是预处理命令，及在预编译阶段进行字符替换，在使用的时候要注意“边缘效应”。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#define kScreen_bounds [[UIScreen mainScreen] bounds]</span></div><div class="line"><span class="meta">#define kScreen_Height [[UIScreen mainScreen] bounds].size.height</span></div><div class="line"><span class="meta">#define kScreen_Width [[UIScreen mainScreen] bounds].size.width</span></div><div class="line"><span class="meta">#define IS_IPHONE4 (([[UIScreen mainScreen] bounds].size.height == 480) ? YES : NO)</span></div><div class="line"><span class="meta">#define IS_IPHONE5 (([[UIScreen mainScreen] bounds].size.height == 568) ? YES : NO)</span></div><div class="line"><span class="meta">#define IS_IPhone6 (([[UIScreen mainScreen] bounds].size.height == 667) ? YES : NO)</span></div><div class="line"><span class="meta">#define IOS_IPhone6plusS (([[UIScreen mainScreen] bounds].size.height = 736) ? YES : NO)</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>所谓的边缘效应是指：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#define sum(a) a + 5</span></div><div class="line"><span class="built_in">CGFloat</span> minus = sum(<span class="number">5</span>) * <span class="number">4</span>;</div><div class="line"><span class="comment">// 由于宏定义只是简单的替换，所以minus的结果不是40，而是 5 + 5 * 4 = 25;这就是边缘效应。</span></div><div class="line"><span class="comment">// 正确使用方式 #define sum(a) (a + 5)</span></div></pre></td></tr></table></figure>
<h3 id="什么时候创建分类"><a href="#什么时候创建分类" class="headerlink" title="什么时候创建分类"></a>什么时候创建分类</h3><p>如果想要给系统的类增添新的方法可以使用分类，比如给UIButton，UIImageView，UIBarButtonItem创建分类等。分类的方法是向下有效的，及会影响到该类的所有子类。</p>
<ul>
<li>分类只能用于添加成员方法，不能用于添加成员变量。</li>
<li>分类增加的方法，如果与原来的类方法同名，会覆盖原来的方法，因为Category的优先级更高</li>
</ul>
<h3 id="什么时候使用继承"><a href="#什么时候使用继承" class="headerlink" title="什么时候使用继承"></a>什么时候使用继承</h3><p>假如目标了你有许多子类，我们希望扩展这个类，又不希望影响到原有的代码，继承后比较好。如果仅仅是扩展方法，分类更好（不需要涉及到原先的代码）</p>
<ul>
<li>可以添加成员变量，也可以添加成员方法。</li>
<li>继承增加的方法不会成为基类的一部分。</li>
</ul>
<h3 id="什么时候封装第三方库"><a href="#什么时候封装第三方库" class="headerlink" title="什么时候封装第三方库"></a>什么时候封装第三方库</h3><p>使用第三方库的好处：</p>
<ul>
<li>缩短开发周期</li>
<li>成熟的第三方库很多人一起维护，Bug很少</li>
<li>有些功能自己没有能力实现</li>
</ul>
<p>有哪些第三方库需要封装？</p>
<ul>
<li>网络AFNetworking</li>
<li>数据库fmdb</li>
<li>……</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="http://blog.csdn.net/fiona_yang123456/article/details/41044979" target="_blank" rel="external">iOS中继承与分类</a></li>
<li><a href="https://my.oschina.net/jack088/blog/605813" target="_blank" rel="external">iOS分类、扩展和继承的区别</a></li>
<li><a href="http://www.jianshu.com/p/97f0684a7dd8" target="_blank" rel="external">封装第三方库的必要性</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要记录一些开发中常用的技巧。比如常用的常量文件，宏定义文件，什么时候创建分类，什么时候使用继承，什么时候使用代理封装第三方库（哪些第三方库需要封装，如何封装）等等。&lt;/p&gt;
&lt;h3 id=&quot;关于常量&quot;&gt;&lt;a href=&quot;#关于常量&quot; class=&quot;headerlink&quot; title=&quot;关于常量&quot;&gt;&lt;/a&gt;关于常量&lt;/h3&gt;&lt;p&gt;很显然不变的量就是常量，比较常用的地方就是整形，浮点型，字符串等。这个时候不建议使用#define来定义。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; weight = &lt;span class=&quot;number&quot;&gt;70&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;// 定义一个整形常量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; height = &lt;span class=&quot;number&quot;&gt;166.0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;// 定义一个浮点型常量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; *city = &lt;span class=&quot;string&quot;&gt;@&quot;上海&quot;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;// 定义一个常量字符串&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;关于宏定义&quot;&gt;&lt;a href=&quot;#关于宏定义&quot; class=&quot;headerlink&quot; title=&quot;关于宏定义&quot;&gt;&lt;/a&gt;关于宏定义&lt;/h3&gt;&lt;p&gt;宏定义是预处理命令，及在预编译阶段进行字符替换，在使用的时候要注意“边缘效应”。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define kScreen_bounds [[UIScreen mainScreen] bounds]&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define kScreen_Height [[UIScreen mainScreen] bounds].size.height&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define kScreen_Width [[UIScreen mainScreen] bounds].size.width&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define IS_IPHONE4 (([[UIScreen mainScreen] bounds].size.height == 480) ? YES : NO)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define IS_IPHONE5 (([[UIScreen mainScreen] bounds].size.height == 568) ? YES : NO)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define IS_IPhone6 (([[UIScreen mainScreen] bounds].size.height == 667) ? YES : NO)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#define IOS_IPhone6plusS (([[UIScreen mainScreen] bounds].size.height = 736) ? YES : NO)&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>控制器中视图的布局</title>
    <link href="http://sz8023.github.io/2016/03/11/iOS-20160916%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E8%A7%86%E5%9B%BE%E7%9A%84%E5%B8%83%E5%B1%80/"/>
    <id>http://sz8023.github.io/2016/03/11/iOS-20160916控制器中视图的布局/</id>
    <published>2016-03-11T06:35:28.000Z</published>
    <updated>2016-09-22T05:35:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>控制器中除了默认的根视图不需要我们适配之外，根视图的所有子视图几乎都需要我们进行适配。如果是纯代码的话你可以在<code>- (void)viewDidLoad</code>中进行适配(相对父视图进行布局)。但是如果你想要跟新rootView的子视图，你需要在<code>viewWillLayoutSubviews</code>或<code>viewDidLayoutSubviews</code>方法中进行更新。这2个方法的主要区别是前者根视图适配完成，但是子视图适配并没有确定（需要根据设备来确定），而后者子视图的适配已经完成。如果你参考非根视图进行布局更新，建议在后者方法中进行布局更新。如果参考根视图则任意选择。</p>
<p>当然你也可以在其他方法中通过调动[view setNeedsLayout]和[view layoutIfNeeded]给控件进行提前布局。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>控件szView和szLBL分别是根视图view的子视图。ViewController采用storyboard的方式进行编码。</p>
<pre><code><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *szView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *szLBL;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)awakeFromNib &#123;</div><div class="line">    [<span class="keyword">super</span> awakeFromNib];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.view.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szView.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szLBL.frame));</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.view.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szView.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szLBL.frame));</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    [<span class="keyword">super</span> viewWillAppear: animated];</div><div class="line"><span class="comment">//    [self.view layoutIfNeeded];</span></div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.view.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szView.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szLBL.frame));</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewWillLayoutSubviews &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.view.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szView.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szLBL.frame));</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLayoutSubviews &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.view.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szView.frame));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s *****\t %@"</span>,__func__,<span class="built_in">NSStringFromCGRect</span>(<span class="keyword">self</span>.szLBL.frame));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><a id="more"></a>
<p>打印结果如下：</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"> <span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.735</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewDidLoad] *****	 &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">414</span>, <span class="number">736</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.736</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewDidLoad] *****	 &#123;&#123;<span class="number">30</span>, <span class="number">50</span>&#125;, &#123;<span class="number">315</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.736</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewDidLoad] *****	 &#123;&#123;<span class="number">100</span>, <span class="number">190</span>&#125;, &#123;<span class="number">175</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.736</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController awakeFromNib] *****	 &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">414</span>, <span class="number">736</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.736</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController awakeFromNib] *****	 &#123;&#123;<span class="number">30</span>, <span class="number">50</span>&#125;, &#123;<span class="number">315</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.737</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController awakeFromNib] *****	 &#123;&#123;<span class="number">100</span>, <span class="number">190</span>&#125;, &#123;<span class="number">175</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.743</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewWillAppear:] *****	 &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">414</span>, <span class="number">736</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.743</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewWillAppear:] *****	 &#123;&#123;<span class="number">30</span>, <span class="number">50</span>&#125;, &#123;<span class="number">315</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.743</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewWillAppear:] *****	 &#123;&#123;<span class="number">100</span>, <span class="number">190</span>&#125;, &#123;<span class="number">175</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.750</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewWillLayoutSubviews] *****	 &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">414</span>, <span class="number">736</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.750</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewWillLayoutSubviews] *****	 &#123;&#123;<span class="number">30</span>, <span class="number">50</span>&#125;, &#123;<span class="number">315</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.754</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewWillLayoutSubviews] *****	 &#123;&#123;<span class="number">100</span>, <span class="number">190</span>&#125;, &#123;<span class="number">175</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.754</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewDidLayoutSubviews] *****	 &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">414</span>, <span class="number">736</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.754</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewDidLayoutSubviews] *****	 &#123;&#123;<span class="number">30</span>, <span class="number">50</span>&#125;, &#123;<span class="number">354</span>, <span class="number">100</span>&#125;&#125;</div><div class="line"><span class="number">2016</span><span class="number">-09</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29.755</span> JustTest[<span class="number">6036</span>:<span class="number">178408</span>] -[ViewController viewDidLayoutSubviews] *****	 &#123;&#123;<span class="number">100</span>, <span class="number">190</span>&#125;, &#123;<span class="number">214</span>, <span class="number">100</span>&#125;&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;控制器中除了默认的根视图不需要我们适配之外，根视图的所有子视图几乎都需要我们进行适配。如果是纯代码的话你可以在&lt;code&gt;- (void)viewDidLoad&lt;/code&gt;中进行适配(相对父视图进行布局)。但是如果你想要跟新rootView的子视图，你需要在&lt;code&gt;viewWillLayoutSubviews&lt;/code&gt;或&lt;code&gt;viewDidLayoutSubviews&lt;/code&gt;方法中进行更新。这2个方法的主要区别是前者根视图适配完成，但是子视图适配并没有确定（需要根据设备来确定），而后者子视图的适配已经完成。如果你参考非根视图进行布局更新，建议在后者方法中进行布局更新。如果参考根视图则任意选择。&lt;/p&gt;
&lt;p&gt;当然你也可以在其他方法中通过调动[view setNeedsLayout]和[view layoutIfNeeded]给控件进行提前布局。&lt;/p&gt;
&lt;h3 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h3&gt;&lt;p&gt;控件szView和szLBL分别是根视图view的子视图。ViewController采用storyboard的方式进行编码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&quot;ViewController.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewController&lt;/span&gt; ()&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;IBOutlet&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *szView;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;IBOutlet&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;UILabel&lt;/span&gt; *szLBL;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewController&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)awakeFromNib &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; awakeFromNib];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szView.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szLBL.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLoad &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewDidLoad];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szView.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szLBL.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewWillAppear:(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)animated &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewWillAppear: animated];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//    [self.view layoutIfNeeded];&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szView.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szLBL.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewWillLayoutSubviews &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szView.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szLBL.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLayoutSubviews &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szView.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%s *****\t %@&quot;&lt;/span&gt;,__func__,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.szLBL.frame));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>代理和通知</title>
    <link href="http://sz8023.github.io/2016/02/10/iOS-%E4%BB%A3%E7%90%86%E5%92%8C%E9%80%9A%E7%9F%A5/"/>
    <id>http://sz8023.github.io/2016/02/10/iOS-代理和通知/</id>
    <published>2016-02-09T23:46:27.000Z</published>
    <updated>2016-09-22T05:43:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发中离不开代理（或Block）和通知。到底什么时候使用代理，什么时候使用通知呢？首先我们从概念入手。<br><!--此处概念来自苹果官网或者stackoverflow--></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>协议Protocol：</strong>接口是一堆方法的声明，但是没有实现。协议也是一堆方法的声明没有实现，在此基础上增加了选择实现和必须实现方法的选择。</p>
<p><strong>代理Delegate：</strong>传入的对象代替了当前类完成了某个功能，成为代理模式。使用场景，对象A发生了某些事情想要告诉对象B的时候或者对象B想要监听对象A发生了什么事情，都可以让对象B成为对象A的代理。</p>
<p><strong>通知Notification：</strong> 通知可以实现多个对象之间传递消息，不论对象之间的层次关系多么复杂。通知是线程同步的。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>通知和代理都可以实现对象和对象之间的传值，不同之处在与代理实现的是逻辑关系简单，视图层次不复杂的一对一传值，而通知用的比较多的场合是逻辑关系较为复杂，视图层次比较深的一对多传值。</p>
<h4 id="什么时候使用代理"><a href="#什么时候使用代理" class="headerlink" title="什么时候使用代理"></a>什么时候使用代理</h4><ul>
<li>自定义控件的时候，如果想要将控件的点击事件传递出去，需要使用代理。</li>
<li>控制器传值，如果想要将目标控制器中的数据传递给源控制器可以使用代理。</li>
<li>网络部分也可以通过代理的方式来处理响应结果。</li>
</ul>
<p>可以使用代理的地方都可以使用block来代替，而且使用方式更简单！</p>
<a id="more"></a>
<h4 id="什么时候使用通知"><a href="#什么时候使用通知" class="headerlink" title="什么时候使用通知"></a>什么时候使用通知</h4><p>如果是自定义的view，那么可以在init方法中添加通知，如果是控制器，可以在viewDidLoad方法中添加通知，在dealloc方法中移除通知，移除通知的时候，一定要使用<code>removeObserver: name: object:</code>带有name的方法，这样可以避免移除该对象的其他通知（可能是系统自带的通知）。</p>
<ul>
<li>如果自定义控件存在多层嵌套，可以使用通知来传递事件</li>
<li>如果一个控制器想要通知其他控制器刷新界面的时候可以使用通知</li>
</ul>
<h3 id="开发中哪些地方会用到"><a href="#开发中哪些地方会用到" class="headerlink" title="开发中哪些地方会用到"></a>开发中哪些地方会用到</h3><p>从顺传和逆传的角度考虑</p>
<ul>
<li>自定义控件</li>
<li>控制器之间传值</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发中离不开代理（或Block）和通知。到底什么时候使用代理，什么时候使用通知呢？首先我们从概念入手。&lt;br&gt;&lt;!--此处概念来自苹果官网或者stackoverflow--&gt;&lt;/p&gt;
&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;协议Protocol：&lt;/strong&gt;接口是一堆方法的声明，但是没有实现。协议也是一堆方法的声明没有实现，在此基础上增加了选择实现和必须实现方法的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理Delegate：&lt;/strong&gt;传入的对象代替了当前类完成了某个功能，成为代理模式。使用场景，对象A发生了某些事情想要告诉对象B的时候或者对象B想要监听对象A发生了什么事情，都可以让对象B成为对象A的代理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通知Notification：&lt;/strong&gt; 通知可以实现多个对象之间传递消息，不论对象之间的层次关系多么复杂。通知是线程同步的。&lt;/p&gt;
&lt;h3 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h3&gt;&lt;p&gt;通知和代理都可以实现对象和对象之间的传值，不同之处在与代理实现的是逻辑关系简单，视图层次不复杂的一对一传值，而通知用的比较多的场合是逻辑关系较为复杂，视图层次比较深的一对多传值。&lt;/p&gt;
&lt;h4 id=&quot;什么时候使用代理&quot;&gt;&lt;a href=&quot;#什么时候使用代理&quot; class=&quot;headerlink&quot; title=&quot;什么时候使用代理&quot;&gt;&lt;/a&gt;什么时候使用代理&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;自定义控件的时候，如果想要将控件的点击事件传递出去，需要使用代理。&lt;/li&gt;
&lt;li&gt;控制器传值，如果想要将目标控制器中的数据传递给源控制器可以使用代理。&lt;/li&gt;
&lt;li&gt;网络部分也可以通过代理的方式来处理响应结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用代理的地方都可以使用block来代替，而且使用方式更简单！&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义控件</title>
    <link href="http://sz8023.github.io/2016/01/14/iOS-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    <id>http://sz8023.github.io/2016/01/14/iOS-自定义控件/</id>
    <published>2016-01-14T09:04:37.000Z</published>
    <updated>2016-09-19T08:03:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS的开发中，系统自带的控件有时候根本无法满足开发的需要，这个时候你就需要自定义控件。关于自定义控件我是这么理解的。</p>
<ul>
<li>如果可以修改原生控件，那么就去修改原生的控件，毕竟系统的控件自带了很多高性能的功能给我们使用。比如修改原生控件的布局。</li>
<li>可以在原生控件的基础上进行再造轮子，比如添加一些控件，这样就可以保留原生控件的一些性能。</li>
<li>完全自定义控件，这个时候你可能需要考虑2个问题，这个控件是否支持Xib或storyboard，还是仅仅支持代码的格式。</li>
</ul>
<p>基于以上的几种情况，大致进行了一些总结。</p>
<h3 id="修改原生控件的布局"><a href="#修改原生控件的布局" class="headerlink" title="修改原生控件的布局"></a>修改原生控件的布局</h3><p>修改原生控件的布局情况在UIButton这个控件当中尤为明显。比如说UIButton的图片默认是居左显示的，那么有时候可能需要让图片居上，居下或者居右显示。这个时候你就可以选择修改原生控件的布局来结局这个问题。由于<code>layoutSubviews</code>在以下几种情况下回自动调用。</p>
<ol>
<li>init初始化不会出发layoutSubviews。但是用initWithFrame进行初始化的时候，如果rect的值不为CGRectZero时，也会触发。</li>
<li>addSubview会触发layoutSubviews</li>
<li>设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化</li>
<li>滚动一个UIScrollView会触发layoutSubviews</li>
<li>旋转UIScreen会触发父UIView的layoutSubviews事件</li>
<li>改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件</li>
</ol>
<p>以上都是系统自动刷新，那么我们如何进行手动刷新呢？</p>
<ol>
<li>setNeedsLayout：标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但是layoutSubviews一定会被调用</li>
<li>layoutIfNeeded：如果，有需要刷新的标记，立即调用layoutSubviews进行重新布局(如果没有标记，不会调用layoutSubviews)</li>
</ol>
<a id="more"></a>
<p>如果要立即刷新，需要先调用[view setNeedsLayout]，把标记设置为需要布局，然后马上调用[view layoutIfNeeded]，实现布局。</p>
<p>在视图第一次显示之前，标记总是“需要刷新”的，可以直接调用[view layoutIfNeeded]。</p>
<p>所以如果不需要更新布局，那么你只需要在init方法中给添加的子控件布局就可以了。</p>
<pre><code><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</div><div class="line">       <span class="comment">// 在此处对子控件进行布局</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>你可是在<code>- (void)layoutSubviews</code>中对子控件更新布局。</p>
<h3 id="原生基础上再造轮子"><a href="#原生基础上再造轮子" class="headerlink" title="原生基础上再造轮子"></a>原生基础上再造轮子</h3><p>依然是同样的一个问题，如果是图片需要显示在顶部。如果你不是修改UIButton中title和image的布局，那么你可以给UIImageView进行重新改造。</p>
<pre><code><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"SZImageView.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SZImageView</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)awakeFromNib &#123;</div><div class="line">    [<span class="keyword">super</span> awakeFromNib];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> addCustomView];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</div><div class="line">        [<span class="keyword">self</span> addCustomView];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addCustomView &#123;</div><div class="line">    <span class="built_in">UILabel</span> *imgLBL = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.bounds), <span class="built_in">CGRectGetHeight</span>(<span class="keyword">self</span>.bounds)/<span class="number">4.0</span>)];</div><div class="line">    [<span class="keyword">self</span> addSubview:imgLBL];</div><div class="line">    <span class="keyword">self</span>.imgLBL = imgLBL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>不过这个时候如果你需要给这个控件添加事件的话，可能还需要再添加手势了，此处不做进一步讨论。</p>
<h3 id="完全自定义控件"><a href="#完全自定义控件" class="headerlink" title="完全自定义控件"></a>完全自定义控件</h3><p>同一个问题不同的解决思路，你也可以通过继承UIView来自定义一个这样的控件。你需要在这个UIView上绘制Image，绘制Text。最简单的方式就是在UIView里面添加一个UIImageView和UILabel，通过修改它们的布局来达到我们想要的效果。</p>
<p>……</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在<code>- (void)layoutSubviews</code>方法中，你需要先调用父类的方法，然后再开始自己的布局。当然这个布局是相对于当前视图的布局，因为当前receiver的frame一定是确定的，而receiver的其他子控件可能由于设备的大小问题，而存在适配问题，不过你也可以再进行子控件的相对布局之前。调用子控件的<code>layoutIfNeeded</code>方法来确定他的frame。</p>
<p>对于控制器中的视图布局，在后期会做一点介绍，感觉文章质量有待进一步提升~_~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS的开发中，系统自带的控件有时候根本无法满足开发的需要，这个时候你就需要自定义控件。关于自定义控件我是这么理解的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果可以修改原生控件，那么就去修改原生的控件，毕竟系统的控件自带了很多高性能的功能给我们使用。比如修改原生控件的布局。&lt;/li&gt;
&lt;li&gt;可以在原生控件的基础上进行再造轮子，比如添加一些控件，这样就可以保留原生控件的一些性能。&lt;/li&gt;
&lt;li&gt;完全自定义控件，这个时候你可能需要考虑2个问题，这个控件是否支持Xib或storyboard，还是仅仅支持代码的格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于以上的几种情况，大致进行了一些总结。&lt;/p&gt;
&lt;h3 id=&quot;修改原生控件的布局&quot;&gt;&lt;a href=&quot;#修改原生控件的布局&quot; class=&quot;headerlink&quot; title=&quot;修改原生控件的布局&quot;&gt;&lt;/a&gt;修改原生控件的布局&lt;/h3&gt;&lt;p&gt;修改原生控件的布局情况在UIButton这个控件当中尤为明显。比如说UIButton的图片默认是居左显示的，那么有时候可能需要让图片居上，居下或者居右显示。这个时候你就可以选择修改原生控件的布局来结局这个问题。由于&lt;code&gt;layoutSubviews&lt;/code&gt;在以下几种情况下回自动调用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;init初始化不会出发layoutSubviews。但是用initWithFrame进行初始化的时候，如果rect的值不为CGRectZero时，也会触发。&lt;/li&gt;
&lt;li&gt;addSubview会触发layoutSubviews&lt;/li&gt;
&lt;li&gt;设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化&lt;/li&gt;
&lt;li&gt;滚动一个UIScrollView会触发layoutSubviews&lt;/li&gt;
&lt;li&gt;旋转UIScreen会触发父UIView的layoutSubviews事件&lt;/li&gt;
&lt;li&gt;改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上都是系统自动刷新，那么我们如何进行手动刷新呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;setNeedsLayout：标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但是layoutSubviews一定会被调用&lt;/li&gt;
&lt;li&gt;layoutIfNeeded：如果，有需要刷新的标记，立即调用layoutSubviews进行重新布局(如果没有标记，不会调用layoutSubviews)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>UIScrollView中键盘的显示和隐藏</title>
    <link href="http://sz8023.github.io/2015/12/03/iOS-%E9%94%AE%E7%9B%98UIKeyboard%E7%9A%84%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8F/"/>
    <id>http://sz8023.github.io/2015/12/03/iOS-键盘UIKeyboard的显示和隐藏/</id>
    <published>2015-12-03T09:54:14.000Z</published>
    <updated>2016-09-03T14:25:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>实际开发当中，经常会遇到需要显示和隐藏键盘的需求。那么在什么情况下需要隐藏键盘呢？<br>首先经常会弹出键盘的控件主要有<code>UITextField</code>、<code>UITextView</code>等。而这些控件的父控件要么是常规的视图，如<code>UIView</code>、<code>UIScrollView</code>或<code>UITableView</code>等。这个时候也许我们就要分2种情况来处理了。</p>
<h4 id="UIView处理方案"><a href="#UIView处理方案" class="headerlink" title="UIView处理方案"></a>UIView处理方案</h4><p>如果使用的是UIView而不是UIScrollView，那么实现方式很简单，只要重写这个方法处理键盘事件就可以了。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">        [textfield endEditing:<span class="literal">YES</span>];</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>但是上面的情况不会处理UIscrollView，因为：</p>
<ul>
<li>UIScrollView是UIView的子控件</li>
<li>UIScrollView会先接受触摸事件，并不会把UIEvent传递给UIView</li>
</ul>
<h4 id="UIScrollView处理方案"><a href="#UIScrollView处理方案" class="headerlink" title="UIScrollView处理方案"></a>UIScrollView处理方案</h4><p>UIScrollView如果只是在Drag的时候处理键盘，那么处理方式比较简单，你只需要做这样的一个简单设置即可</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">scrollView.keyboardDismissMode = <span class="built_in">UIScrollViewKeyboardDismissModeOnDrag</span>;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>但是如果你还想要给UIScrollView添加点击事件来处理键盘，那么你就需要给视图添加一个手势来识别它。Coding like this</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">UITapGestureRecognizer</span> *tapGesture = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(tapEvent:)];</div><div class="line">tapGesture.delegate = <span class="keyword">self</span>;</div><div class="line">tapGesture.numberOfTapsRequired = <span class="number">1</span>;</div><div class="line">tapGesture.numberOfTouchesRequired = <span class="number">1</span>;</div><div class="line">[scrollView addGestureRecognizer:tapGesture];</div></pre></td></tr></table></figure>
<p>然后在代理方法中你需要这样来处理</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tapEvent &#123;</div><div class="line">    [<span class="keyword">self</span>.view endEditing:<span class="literal">YES</span>];</div><div class="line"><span class="comment">//     或者想这样</span></div><div class="line"><span class="comment">//    [textField endEditing:YES];</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你将手势运用在UITableView中的话，那么cell可能就无法接收到点击事件了，也就是说方法<code>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath</code>走不通了。</p>
<p>为什么cell接收不到事件呢？可能你还需要了解这些知识<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html" target="_blank" rel="external">Responder Chain</a></p>
<p>针对这样的问题，你需要实现手势的代理方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class="built_in">UITouch</span> *)touch &#123;</div><div class="line">    <span class="comment">// 若为UITableViewCellContentView，就不接受tap事件</span></div><div class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>([touch.view <span class="keyword">class</span>]) isEqualToString:<span class="string">@"UITableViewCellContentView"</span>]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际开发当中，经常会遇到需要显示和隐藏键盘的需求。那么在什么情况下需要隐藏键盘呢？&lt;br&gt;首先经常会弹出键盘的控件主要有&lt;code&gt;UITextField&lt;/code&gt;、&lt;code&gt;UITextView&lt;/code&gt;等。而这些控件的父控件要么是常规的视图，如&lt;code&gt;UIView&lt;/code&gt;、&lt;code&gt;UIScrollView&lt;/code&gt;或&lt;code&gt;UITableView&lt;/code&gt;等。这个时候也许我们就要分2种情况来处理了。&lt;/p&gt;
&lt;h4 id=&quot;UIView处理方案&quot;&gt;&lt;a href=&quot;#UIView处理方案&quot; class=&quot;headerlink&quot; title=&quot;UIView处理方案&quot;&gt;&lt;/a&gt;UIView处理方案&lt;/h4&gt;&lt;p&gt;如果使用的是UIView而不是UIScrollView，那么实现方式很简单，只要重写这个方法处理键盘事件就可以了。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)touchesBegan:(&lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt; *)touches withEvent:(&lt;span class=&quot;built_in&quot;&gt;UIEvent&lt;/span&gt; *)event &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        [textfield endEditing:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是上面的情况不会处理UIscrollView，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UIScrollView是UIView的子控件&lt;/li&gt;
&lt;li&gt;UIScrollView会先接受触摸事件，并不会把UIEvent传递给UIView&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;UIScrollView处理方案&quot;&gt;&lt;a href=&quot;#UIScrollView处理方案&quot; class=&quot;headerlink&quot; title=&quot;UIScrollView处理方案&quot;&gt;&lt;/a&gt;UIScrollView处理方案&lt;/h4&gt;&lt;p&gt;UIScrollView如果只是在Drag的时候处理键盘，那么处理方式比较简单，你只需要做这样的一个简单设置即可&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;scrollView.keyboardDismissMode = &lt;span class=&quot;built_in&quot;&gt;UIScrollViewKeyboardDismissModeOnDrag&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="实用技巧" scheme="http://sz8023.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>手势解锁实现</title>
    <link href="http://sz8023.github.io/2015/11/12/iOS-%E6%89%8B%E5%8A%BF%E8%A7%A3%E9%94%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://sz8023.github.io/2015/11/12/iOS-手势解锁实现/</id>
    <published>2015-11-12T01:39:53.000Z</published>
    <updated>2016-09-02T03:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>如今很多涉及到安全方面的app都会有手势解锁这个功能。这个功能看似简单，其实还是有很多的注意点在里面。以下是我写的一个简单的手势解锁。</p>
<p>如果你需要改变根控制器的view，你可以自定义，我这边简单定义了一下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  BGView.m</span></div><div class="line"><span class="comment">//  05-手势解锁</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by styshy on 15/11/4.</span></div><div class="line"><span class="comment">//  Copyright (c) 2015年 sz. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"BGView.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BGView</span></span></div><div class="line"></div><div class="line"><span class="comment">// 在drawRect中绘制图片</span></div><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123;</div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Home_refresh_bg"</span>];</div><div class="line">    [image drawInRect:rect];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>主要的手势解锁在LockView这个类中，部分代码存在注释。这个LockView也是手势的主要绘制区域</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  LockView.m</span></div><div class="line"><span class="comment">//  05-手势解锁</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by styshy on 15/11/4.</span></div><div class="line"><span class="comment">//  Copyright (c) 2015年 sz. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"LockView.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LockView</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *buttons;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">CGPoint</span> curP;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LockView</span></span></div><div class="line"></div><div class="line"><span class="comment">// 懒加载</span></div><div class="line">- (<span class="built_in">NSMutableArray</span> *)buttons&#123;</div><div class="line">    <span class="keyword">if</span> (_buttons == <span class="literal">nil</span>) &#123;</div><div class="line">        _buttons = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _buttons;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 添加按钮</span></div><div class="line">- (<span class="keyword">void</span>)awakeFromNib&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++) &#123;</div><div class="line">        <span class="comment">// 创建按钮</span></div><div class="line">        <span class="built_in">UIButton</span> *button = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</div><div class="line">        </div><div class="line">        <span class="comment">// 设置按钮的背景图片</span></div><div class="line">        [button setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"gesture_node_normal"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">        [button setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"gesture_node_selected"</span>] forState:<span class="built_in">UIControlStateSelected</span>];</div><div class="line">        </div><div class="line">        [button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(btnClick:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">        </div><div class="line">        <span class="comment">// 将按钮添加到视图当中</span></div><div class="line">        [<span class="keyword">self</span> addSubview:button];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 按钮的高亮状态是系统自动达到的,当用户长按按钮的时候就会达到高亮状态</span></div><div class="line"><span class="comment">// 按钮的选中状态必须通过代码手动达到</span></div><div class="line">- (<span class="keyword">void</span>)btnClick:(<span class="built_in">UIButton</span> *)btn&#123;</div><div class="line">    btn.selected = <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 布局按钮</span></div><div class="line">- (<span class="keyword">void</span>)layoutSubviews&#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> layoutSubviews];</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> WH = <span class="number">74</span>;</div><div class="line">    <span class="built_in">CGFloat</span> btnX = <span class="number">0</span>;</div><div class="line">    <span class="built_in">CGFloat</span> btnY = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> totalCols = <span class="number">3</span>;</div><div class="line">    <span class="keyword">int</span> btnCol = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> btnRow = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> margin = (<span class="keyword">self</span>.bounds.size.width - totalCols * WH)/(totalCols + <span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)<span class="keyword">self</span>.subviews.count;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i ++) &#123;</div><div class="line">        <span class="comment">// 当前按钮的所在列</span></div><div class="line">        btnCol =(<span class="keyword">int</span>) i % totalCols;</div><div class="line">        <span class="comment">// 当前按钮所在行</span></div><div class="line">        btnRow = i / totalCols;</div><div class="line">        <span class="comment">// 当前按钮的x坐标</span></div><div class="line">        btnX = margin + btnCol * (margin + WH);</div><div class="line">        <span class="comment">// 当前按钮的y坐标</span></div><div class="line">        btnY = margin + btnRow * (margin + WH);</div><div class="line">        </div><div class="line">        <span class="built_in">UIButton</span> *button = <span class="keyword">self</span>.subviews[i];</div><div class="line">        </div><div class="line">        button.frame = <span class="built_in">CGRectMake</span>(btnX, btnY, WH,WH);</div><div class="line">        <span class="comment">// 将按钮的交互状态转给drawRect方法处理</span></div><div class="line">        button.userInteractionEnabled = <span class="literal">NO</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// 记录按钮，每个按钮都有一个数字标示</span></div><div class="line">        button.tag = i;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 手势移动</span></div><div class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    <span class="comment">// 获取手势</span></div><div class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</div><div class="line">    <span class="comment">// 获取当前的位置坐标</span></div><div class="line">    <span class="built_in">CGPoint</span> point = [touch locationInView:<span class="keyword">self</span>];</div><div class="line">    <span class="keyword">self</span>.curP = point;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIButton</span>* button <span class="keyword">in</span> <span class="keyword">self</span>.subviews) &#123;</div><div class="line">        <span class="comment">// 判断当前按钮是否被选中</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(button.frame, point)) &#123;</div><div class="line">            <span class="keyword">if</span> (button.selected == <span class="literal">NO</span>) &#123;</div><div class="line">                button.selected = <span class="literal">YES</span>;</div><div class="line">                [<span class="keyword">self</span>.buttons addObject:button];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 重回</span></div><div class="line">    [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 手势结束</span></div><div class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> string];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIButton</span> * btn <span class="keyword">in</span> <span class="keyword">self</span>.buttons) &#123;</div><div class="line">        [str appendFormat:<span class="string">@"%ld"</span>,btn.tag];</div><div class="line">        btn.selected = <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str);</div><div class="line">    </div><div class="line">    <span class="comment">// 清空所有的选中按钮</span></div><div class="line">    [<span class="keyword">self</span>.buttons removeAllObjects];</div><div class="line">    </div><div class="line">    <span class="comment">// 重新绘图</span></div><div class="line">    [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 绘图</span></div><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123;</div><div class="line">    <span class="comment">// 如果没有选中的按钮，则直接返回</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.buttons.count == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 创建路径</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *path = [[<span class="built_in">UIBezierPath</span> alloc] init];</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)<span class="keyword">self</span>.buttons.count;</div><div class="line">    </div><div class="line">    <span class="comment">// 去除path，绘制线条</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; count; i ++) &#123;</div><div class="line">        <span class="built_in">UIButton</span> *selectedBtn = <span class="keyword">self</span>.buttons[i];</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == i) &#123;</div><div class="line">            [path moveToPoint:selectedBtn.center];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            [path addLineToPoint:selectedBtn.center];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [path addLineToPoint:<span class="keyword">self</span>.curP];</div><div class="line">    </div><div class="line">    [path setLineWidth:<span class="number">8</span>];<span class="comment">// 设置线宽</span></div><div class="line">    [[<span class="built_in">UIColor</span> greenColor] set];<span class="comment">//设置线条颜色</span></div><div class="line">    [path stroke];<span class="comment">//绘制空心线条</span></div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>效果展示图片：</p>
<p><img src="../images/LockView.gif" alt="LockView"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如今很多涉及到安全方面的app都会有手势解锁这个功能。这个功能看似简单，其实还是有很多的注意点在里面。以下是我写的一个简单的手势解锁。&lt;/p&gt;
&lt;p&gt;如果你需要改变根控制器的view，你可以自定义，我这边简单定义了一下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  BGView.m&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  05-手势解锁&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  Created by styshy on 15/11/4.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  Copyright (c) 2015年 sz. All rights reserved.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&quot;BGView.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BGView&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在drawRect中绘制图片&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)drawRect:(&lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt;)rect&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; *image = [&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageNamed:&lt;span class=&quot;string&quot;&gt;@&quot;Home_refresh_bg&quot;&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [image drawInRect:rect];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="自定义库" scheme="http://sz8023.github.io/categories/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>SDWebImage学习</title>
    <link href="http://sz8023.github.io/2015/09/01/iOS-SDWebImage%E5%AD%A6%E4%B9%A0/"/>
    <id>http://sz8023.github.io/2015/09/01/iOS-SDWebImage学习/</id>
    <published>2015-08-31T23:42:53.000Z</published>
    <updated>2016-09-03T09:58:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="rs-SDWebImage"><a href="#rs-SDWebImage" class="headerlink" title="rs/SDWebImage"></a><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">rs/SDWebImage</a></h3><p><code>SDWebImage</code>是一个优秀的图片处理框架，你可以通过它来实现异步图片下载，并且支持图片的缓存。</p>
<p>这个第三方库为UIImageView提供了一个分类，支持处理来自网络的图片，主要功能包括以下几点：</p>
<ul>
<li>一个UIImageView的分类来添加图片和缓存处理</li>
<li>一个异步图片下载器</li>
<li>一个异步内存和磁盘图片缓存和对缓存过期的处理</li>
<li>支持Gif图片</li>
<li>支持WebP</li>
<li>背景图片解压</li>
<li>相同URL的图片不会下载多次</li>
<li>假的URL不会尝试一直请求</li>
<li>保证主线程不会卡死</li>
<li>……</li>
</ul>
<h3 id="应该如何使用"><a href="#应该如何使用" class="headerlink" title="应该如何使用"></a>应该如何使用</h3><p><code>SDWebImage</code>为使用者提供了<a href="http://cocoadocs.org/docsets/SDWebImage/3.8.1/" target="_blank" rel="external">API document</a>，以下只是简单列举以下最常见的用法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;SDWebImage/UIImageView+WebCache.h&gt;</span></span></div><div class="line">...</div><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">   <span class="keyword">static</span> <span class="built_in">NSString</span> *MyIdentifier = <span class="string">@"MyIdentifier"</span>;</div><div class="line"></div><div class="line">   <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];</div><div class="line">   <span class="keyword">if</span> (cell == <span class="literal">nil</span>) &#123;</div><div class="line">       cell = [[[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span></div><div class="line">                                      reuseIdentifier:MyIdentifier] autorelease];</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// Here we use the new provided sd_setImageWithURL: method to load the web image</span></div><div class="line">   [cell.imageView sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</div><div class="line">                     placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]];</div><div class="line"></div><div class="line">   cell.textLabel.text = <span class="string">@"My Text"</span>;</div><div class="line">   <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>或者通过使用block的形式</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Here we use the new provided sd_setImageWithURL: method to load the web image</span></div><div class="line">[cell.imageView sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</div><div class="line">                      placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]</div><div class="line">                             completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">                                ... completion code here ...</div><div class="line">                             &#125;];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;rs-SDWebImage&quot;&gt;&lt;a href=&quot;#rs-SDWebImage&quot; class=&quot;headerlink&quot; title=&quot;rs/SDWebImage&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/rs/SDWebImage&quot;&gt;rs/SDWebImage&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt;是一个优秀的图片处理框架，你可以通过它来实现异步图片下载，并且支持图片的缓存。&lt;/p&gt;
&lt;p&gt;这个第三方库为UIImageView提供了一个分类，支持处理来自网络的图片，主要功能包括以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个UIImageView的分类来添加图片和缓存处理&lt;/li&gt;
&lt;li&gt;一个异步图片下载器&lt;/li&gt;
&lt;li&gt;一个异步内存和磁盘图片缓存和对缓存过期的处理&lt;/li&gt;
&lt;li&gt;支持Gif图片&lt;/li&gt;
&lt;li&gt;支持WebP&lt;/li&gt;
&lt;li&gt;背景图片解压&lt;/li&gt;
&lt;li&gt;相同URL的图片不会下载多次&lt;/li&gt;
&lt;li&gt;假的URL不会尝试一直请求&lt;/li&gt;
&lt;li&gt;保证主线程不会卡死&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;应该如何使用&quot;&gt;&lt;a href=&quot;#应该如何使用&quot; class=&quot;headerlink&quot; title=&quot;应该如何使用&quot;&gt;&lt;/a&gt;应该如何使用&lt;/h3&gt;&lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt;为使用者提供了&lt;a href=&quot;http://cocoadocs.org/docsets/SDWebImage/3.8.1/&quot;&gt;API document&lt;/a&gt;，以下只是简单列举以下最常见的用法。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;SDWebImage/UIImageView+WebCache.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; *)tableView:(&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *)tableView cellForRowAtIndexPath:(&lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *)indexPath &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *MyIdentifier = &lt;span class=&quot;string&quot;&gt;@&quot;MyIdentifier&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cell == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       cell = [[[&lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; alloc] initWithStyle:&lt;span class=&quot;built_in&quot;&gt;UITableViewCellStyleDefault&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                      reuseIdentifier:MyIdentifier] autorelease];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// Here we use the new provided sd_setImageWithURL: method to load the web image&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   [cell.imageView sd_setImageWithURL:[&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;http://www.domain.com/path/to/image.jpg&quot;&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                     placeholderImage:[&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageNamed:&lt;span class=&quot;string&quot;&gt;@&quot;placeholder.png&quot;&lt;/span&gt;]];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   cell.textLabel.text = &lt;span class=&quot;string&quot;&gt;@&quot;My Text&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; cell;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="框架学习" scheme="http://sz8023.github.io/tags/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MJExtension学习</title>
    <link href="http://sz8023.github.io/2015/07/05/iOS-MJExtension%E5%AD%A6%E4%B9%A0/"/>
    <id>http://sz8023.github.io/2015/07/05/iOS-MJExtension学习/</id>
    <published>2015-07-05T10:24:10.000Z</published>
    <updated>2016-09-03T09:59:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CoderMJLee-MJExtension"><a href="#CoderMJLee-MJExtension" class="headerlink" title="CoderMJLee/MJExtension"></a><a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="external">CoderMJLee/MJExtension</a></h3><p>大神李明杰的另一个框架，实现Json和Model的互相转换，转换速度快、使用简单方便的字典转模型框架。</p>
<p><code>MJExtension</code>是一套字典和模型之间转换的超轻量级框架</p>
<ul>
<li>JSON –&gt; Model、Core Data Modal</li>
<li>JSONString –&gt; Model、Core Data Model</li>
<li>Model、Core Data Model –&gt; JSON</li>
<li>JSON Array –&gt; Model Array、Core Data Model Array</li>
<li>JSONString –&gt; Model Array、Core Data Model Array</li>
<li>Model Array、Core Data Model Array –&gt; JSON Array</li>
</ul>
<p>Coding all properties of model in one line code.<br>只需要一行代码，就能实现模型的所有属性进行Coding(归档和解档)</p>
<p>同样的，MJExtension也提供了两种使用方式，一种是通过CocoaPods，另一种是通过手动导入的方式。</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CoderMJLee-MJExtension&quot;&gt;&lt;a href=&quot;#CoderMJLee-MJExtension&quot; class=&quot;headerlink&quot; title=&quot;CoderMJLee/MJExtension&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/CoderMJLee/MJExtension&quot;&gt;CoderMJLee/MJExtension&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;大神李明杰的另一个框架，实现Json和Model的互相转换，转换速度快、使用简单方便的字典转模型框架。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MJExtension&lt;/code&gt;是一套字典和模型之间转换的超轻量级框架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSON –&amp;gt; Model、Core Data Modal&lt;/li&gt;
&lt;li&gt;JSONString –&amp;gt; Model、Core Data Model&lt;/li&gt;
&lt;li&gt;Model、Core Data Model –&amp;gt; JSON&lt;/li&gt;
&lt;li&gt;JSON Array –&amp;gt; Model Array、Core Data Model Array&lt;/li&gt;
&lt;li&gt;JSONString –&amp;gt; Model Array、Core Data Model Array&lt;/li&gt;
&lt;li&gt;Model Array、Core Data Model Array –&amp;gt; JSON Array&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Coding all properties of model in one line code.&lt;br&gt;只需要一行代码，就能实现模型的所有属性进行Coding(归档和解档)&lt;/p&gt;
&lt;p&gt;同样的，MJExtension也提供了两种使用方式，一种是通过CocoaPods，另一种是通过手动导入的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="框架学习" scheme="http://sz8023.github.io/tags/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MJRefresh学习</title>
    <link href="http://sz8023.github.io/2015/06/30/iOS-MJRefresh%E5%AD%A6%E4%B9%A0/"/>
    <id>http://sz8023.github.io/2015/06/30/iOS-MJRefresh学习/</id>
    <published>2015-06-30T02:41:24.000Z</published>
    <updated>2016-09-03T09:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CoderMJLee-MJRefresh"><a href="#CoderMJLee-MJRefresh" class="headerlink" title="CoderMJLee/MJRefresh"></a><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="external">CoderMJLee/MJRefresh</a></h3><p>大神李明杰写的一个刷新控件造福了国内的一批程序员，也提高了我们开发项目的进度。</p>
<p><code>MJRefresh</code>的使用方式特别的简单，看看官网你就可以知道如何使用了。</p>
<p><code>MJRefresh</code>支持的刷新控件有：</p>
<ul>
<li>UIScrollView</li>
<li>UITableView</li>
<li>UICollectionView</li>
<li>UIWebView</li>
</ul>
<p>像很多牛逼的第三方一样，<code>MJRefresh</code>也提供了两种使用方式，你可以通过CocoaPods或者手动导入的方式来使用它。</p>
<h3 id="MJRefresh框架的结构图"><a href="#MJRefresh框架的结构图" class="headerlink" title="MJRefresh框架的结构图"></a>MJRefresh框架的结构图</h3><p><img src="../images/MJRefresh.png" width="800px"></p>
<p>使用者可以从这个结构图中清晰的看到自己想要使用的Class，甚至可以根据相应的结构来自己定义刷新控件。</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CoderMJLee-MJRefresh&quot;&gt;&lt;a href=&quot;#CoderMJLee-MJRefresh&quot; class=&quot;headerlink&quot; title=&quot;CoderMJLee/MJRefresh&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/CoderMJLee/MJRefresh&quot;&gt;CoderMJLee/MJRefresh&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;大神李明杰写的一个刷新控件造福了国内的一批程序员，也提高了我们开发项目的进度。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MJRefresh&lt;/code&gt;的使用方式特别的简单，看看官网你就可以知道如何使用了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MJRefresh&lt;/code&gt;支持的刷新控件有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UIScrollView&lt;/li&gt;
&lt;li&gt;UITableView&lt;/li&gt;
&lt;li&gt;UICollectionView&lt;/li&gt;
&lt;li&gt;UIWebView&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;像很多牛逼的第三方一样，&lt;code&gt;MJRefresh&lt;/code&gt;也提供了两种使用方式，你可以通过CocoaPods或者手动导入的方式来使用它。&lt;/p&gt;
&lt;h3 id=&quot;MJRefresh框架的结构图&quot;&gt;&lt;a href=&quot;#MJRefresh框架的结构图&quot; class=&quot;headerlink&quot; title=&quot;MJRefresh框架的结构图&quot;&gt;&lt;/a&gt;MJRefresh框架的结构图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;../images/MJRefresh.png&quot; width=800px&gt;&lt;/p&gt;
&lt;p&gt;使用者可以从这个结构图中清晰的看到自己想要使用的Class，甚至可以根据相应的结构来自己定义刷新控件。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发" scheme="http://sz8023.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="框架学习" scheme="http://sz8023.github.io/tags/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Ruby教程</title>
    <link href="http://sz8023.github.io/2015/05/01/other-Ruby%E6%95%99%E7%A8%8B/"/>
    <id>http://sz8023.github.io/2015/05/01/other-Ruby教程/</id>
    <published>2015-05-01T01:46:31.000Z</published>
    <updated>2016-08-31T10:02:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Ruby教程"><a href="#Ruby教程" class="headerlink" title="Ruby教程"></a>Ruby教程</h3><p>Ruby是一种开源的面向对象程序设计的服务器端脚本语言。Ruby可运行于多种平台，如Windowss、MAC OS和UNIX的各种版本。</p>
<h3 id="编译-执行Ruby程序"><a href="#编译-执行Ruby程序" class="headerlink" title="编译/执行Ruby程序"></a>编译/执行Ruby程序</h3><p>Ruby与Smalltalk一样，是一个完美的面向对象语言，使用Ruby的语法比使用Smalltalk的语法要容易多。</p>
<h3 id="Ruby的特性"><a href="#Ruby的特性" class="headerlink" title="Ruby的特性"></a>Ruby的特性</h3><ul>
<li>Ruby是开源的，在Web上是免费提供的，但需要一个许可证。</li>
<li>Ruby是一种通用 、解释的编程语言。</li>
<li>Ruby是一种真正的面向对象编程语言。</li>
<li>Ruby是一种类似于Python和Perl的服务器端脚本语言</li>
<li>Ruby可以用来编写通用网关接口</li>
<li>Ruby可以被嵌套</li>
<li>……</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Ruby教程&quot;&gt;&lt;a href=&quot;#Ruby教程&quot; class=&quot;headerlink&quot; title=&quot;Ruby教程&quot;&gt;&lt;/a&gt;Ruby教程&lt;/h3&gt;&lt;p&gt;Ruby是一种开源的面向对象程序设计的服务器端脚本语言。Ruby可运行于多种平台，如Windowss、MAC
    
    </summary>
    
      <category term="Ruby教程" scheme="http://sz8023.github.io/categories/Ruby%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>NPM使用介绍</title>
    <link href="http://sz8023.github.io/2015/04/26/other-NPM%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://sz8023.github.io/2015/04/26/other-NPM使用介绍/</id>
    <published>2015-04-26T01:08:19.000Z</published>
    <updated>2016-08-31T10:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js-PEPL-交互式解释器"><a href="#Node-js-PEPL-交互式解释器" class="headerlink" title="Node.js PEPL(交互式解释器)"></a>Node.js PEPL(交互式解释器)</h1><p>我们可以在终端输入命令，并接收系统的响应<br>Node自带了交互式解释器，可以执行如下任务</p>
<ul>
<li>读取 - 读取用户输入，解析输入了JavaScript数据结构并存储在内存中</li>
<li>执行 - 执行输入的用户结构</li>
<li>打印 - 输出结果</li>
<li>循环 - 循环操作以上步骤知道用户两次按下ctrl+c 按钮退出</li>
</ul>
<p>我们可以输入以下命令来启动Node终端</p>
<pre><code>$ node
&gt;
</code></pre><h2 id="Node-js回调函数"><a href="#Node-js回调函数" class="headerlink" title="Node.js回调函数"></a>Node.js回调函数</h2><ul>
<li>Node.js异步编程的直接体现就是回调</li>
<li>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。</li>
<li>回调函数在完成任务之后就会被调用，Node使用了大量的回调函数，Node所有的API都支持回调函数。</li>
</ul>
<h3 id="阻塞代码"><a href="#阻塞代码" class="headerlink" title="阻塞代码"></a>阻塞代码</h3><pre><code>var fs = require(&quot;fs&quot;);
var data = fs.readFileSync(&apos;input.txt&apos;);

console.log(data.toString());
console.log(&quot;程序执行结束&quot;);
</code></pre><h3 id="非阻塞代码"><a href="#非阻塞代码" class="headerlink" title="非阻塞代码"></a>非阻塞代码</h3><pre><code>var fs = require(&quot;fs&quot;);

fs.readFile(&apos;input.txt&apos;,function(err,data) {
    if(err) return console.error(err);
    console.log(data.toString());
});

console.log(&quot;程序执行结束&quot;);
</code></pre><p><em>第一个实例在文件读取之后才执行程序。第二个实例我们不需要等待文件读取完成，这样就可以在读取文件的同时执行接下来的代码</em></p>
<h3 id="Node-js事件循环"><a href="#Node-js事件循环" class="headerlink" title="Node.js事件循环"></a>Node.js事件循环</h3><ul>
<li>Node.js是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。</li>
<li>Node.js的每一个API都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。</li>
<li>Node.js基本上所有的事件机制都是通过设计模式中的观察者模式实现</li>
<li>Node.js单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数。</li>
</ul>
<h3 id="随便"><a href="#随便" class="headerlink" title="随便"></a>随便</h3><pre><code>小到一个变量，数组，大到一个数据库或者网络通信，都离不开数据的增删改查。变量有，数据库也有。网络通信也有。GET,PUT,DELETE,POST
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Node-js-PEPL-交互式解释器&quot;&gt;&lt;a href=&quot;#Node-js-PEPL-交互式解释器&quot; class=&quot;headerlink&quot; title=&quot;Node.js PEPL(交互式解释器)&quot;&gt;&lt;/a&gt;Node.js PEPL(交互式解释器)&lt;/h1&gt;&lt;p&gt;
    
    </summary>
    
      <category term="Node教程" scheme="http://sz8023.github.io/categories/Node%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
</feed>
