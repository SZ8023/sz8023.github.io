<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ForYou</title>
  <subtitle>如果一个人活得很诚恳，那么他一定生活在别处</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sz8023.github.io/"/>
  <updated>2016-09-02T03:06:07.000Z</updated>
  <id>http://sz8023.github.io/</id>
  
  <author>
    <name>styshy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手势解锁实现</title>
    <link href="http://sz8023.github.io/2015/11/12/%E6%89%8B%E5%8A%BF%E8%A7%A3%E9%94%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://sz8023.github.io/2015/11/12/手势解锁实现/</id>
    <published>2015-11-12T01:39:53.000Z</published>
    <updated>2016-09-02T03:06:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>如今很多涉及到安全方面的app都会有手势解锁这个功能。这个功能看似简单，其实还是有很多的注意点在里面。以下是我写的一个简单的手势解锁。</p>
<p>如果你需要改变根控制器的view，你可以自定义，我这边简单定义了一下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  BGView.m</span></div><div class="line"><span class="comment">//  05-手势解锁</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by styshy on 15/11/4.</span></div><div class="line"><span class="comment">//  Copyright (c) 2015年 sz. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"BGView.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BGView</span></span></div><div class="line"></div><div class="line"><span class="comment">// 在drawRect中绘制图片</span></div><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123;</div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Home_refresh_bg"</span>];</div><div class="line">    [image drawInRect:rect];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>主要的手势解锁在LockView这个类中，部分代码存在注释。这个LockView也是手势的主要绘制区域</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  LockView.m</span></div><div class="line"><span class="comment">//  05-手势解锁</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Created by styshy on 15/11/4.</span></div><div class="line"><span class="comment">//  Copyright (c) 2015年 sz. All rights reserved.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"LockView.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LockView</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *buttons;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">CGPoint</span> curP;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LockView</span></span></div><div class="line"></div><div class="line"><span class="comment">// 懒加载</span></div><div class="line">- (<span class="built_in">NSMutableArray</span> *)buttons&#123;</div><div class="line">    <span class="keyword">if</span> (_buttons == <span class="literal">nil</span>) &#123;</div><div class="line">        _buttons = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _buttons;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 添加按钮</span></div><div class="line">- (<span class="keyword">void</span>)awakeFromNib&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++) &#123;</div><div class="line">        <span class="comment">// 创建按钮</span></div><div class="line">        <span class="built_in">UIButton</span> *button = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</div><div class="line">        </div><div class="line">        <span class="comment">// 设置按钮的背景图片</span></div><div class="line">        [button setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"gesture_node_normal"</span>] forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">        [button setBackgroundImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"gesture_node_selected"</span>] forState:<span class="built_in">UIControlStateSelected</span>];</div><div class="line">        </div><div class="line">        [button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(btnClick:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">        </div><div class="line">        <span class="comment">// 将按钮添加到视图当中</span></div><div class="line">        [<span class="keyword">self</span> addSubview:button];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 按钮的高亮状态是系统自动达到的,当用户长按按钮的时候就会达到高亮状态</span></div><div class="line"><span class="comment">// 按钮的选中状态必须通过代码手动达到</span></div><div class="line">- (<span class="keyword">void</span>)btnClick:(<span class="built_in">UIButton</span> *)btn&#123;</div><div class="line">    btn.selected = <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 布局按钮</span></div><div class="line">- (<span class="keyword">void</span>)layoutSubviews&#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> layoutSubviews];</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> WH = <span class="number">74</span>;</div><div class="line">    <span class="built_in">CGFloat</span> btnX = <span class="number">0</span>;</div><div class="line">    <span class="built_in">CGFloat</span> btnY = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> totalCols = <span class="number">3</span>;</div><div class="line">    <span class="keyword">int</span> btnCol = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> btnRow = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> margin = (<span class="keyword">self</span>.bounds.size.width - totalCols * WH)/(totalCols + <span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)<span class="keyword">self</span>.subviews.count;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i ++) &#123;</div><div class="line">        <span class="comment">// 当前按钮的所在列</span></div><div class="line">        btnCol =(<span class="keyword">int</span>) i % totalCols;</div><div class="line">        <span class="comment">// 当前按钮所在行</span></div><div class="line">        btnRow = i / totalCols;</div><div class="line">        <span class="comment">// 当前按钮的x坐标</span></div><div class="line">        btnX = margin + btnCol * (margin + WH);</div><div class="line">        <span class="comment">// 当前按钮的y坐标</span></div><div class="line">        btnY = margin + btnRow * (margin + WH);</div><div class="line">        </div><div class="line">        <span class="built_in">UIButton</span> *button = <span class="keyword">self</span>.subviews[i];</div><div class="line">        </div><div class="line">        button.frame = <span class="built_in">CGRectMake</span>(btnX, btnY, WH,WH);</div><div class="line">        <span class="comment">// 将按钮的交互状态转给drawRect方法处理</span></div><div class="line">        button.userInteractionEnabled = <span class="literal">NO</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// 记录按钮，每个按钮都有一个数字标示</span></div><div class="line">        button.tag = i;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 手势移动</span></div><div class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    <span class="comment">// 获取手势</span></div><div class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</div><div class="line">    <span class="comment">// 获取当前的位置坐标</span></div><div class="line">    <span class="built_in">CGPoint</span> point = [touch locationInView:<span class="keyword">self</span>];</div><div class="line">    <span class="keyword">self</span>.curP = point;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIButton</span>* button <span class="keyword">in</span> <span class="keyword">self</span>.subviews) &#123;</div><div class="line">        <span class="comment">// 判断当前按钮是否被选中</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(button.frame, point)) &#123;</div><div class="line">            <span class="keyword">if</span> (button.selected == <span class="literal">NO</span>) &#123;</div><div class="line">                button.selected = <span class="literal">YES</span>;</div><div class="line">                [<span class="keyword">self</span>.buttons addObject:button];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 重回</span></div><div class="line">    [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 手势结束</span></div><div class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> string];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIButton</span> * btn <span class="keyword">in</span> <span class="keyword">self</span>.buttons) &#123;</div><div class="line">        [str appendFormat:<span class="string">@"%ld"</span>,btn.tag];</div><div class="line">        btn.selected = <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str);</div><div class="line">    </div><div class="line">    <span class="comment">// 清空所有的选中按钮</span></div><div class="line">    [<span class="keyword">self</span>.buttons removeAllObjects];</div><div class="line">    </div><div class="line">    <span class="comment">// 重新绘图</span></div><div class="line">    [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 绘图</span></div><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123;</div><div class="line">    <span class="comment">// 如果没有选中的按钮，则直接返回</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.buttons.count == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">// 创建路径</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *path = [[<span class="built_in">UIBezierPath</span> alloc] init];</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>)<span class="keyword">self</span>.buttons.count;</div><div class="line">    </div><div class="line">    <span class="comment">// 去除path，绘制线条</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; count; i ++) &#123;</div><div class="line">        <span class="built_in">UIButton</span> *selectedBtn = <span class="keyword">self</span>.buttons[i];</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == i) &#123;</div><div class="line">            [path moveToPoint:selectedBtn.center];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            [path addLineToPoint:selectedBtn.center];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [path addLineToPoint:<span class="keyword">self</span>.curP];</div><div class="line">    </div><div class="line">    [path setLineWidth:<span class="number">8</span>];<span class="comment">// 设置线宽</span></div><div class="line">    [[<span class="built_in">UIColor</span> greenColor] set];<span class="comment">//设置线条颜色</span></div><div class="line">    [path stroke];<span class="comment">//绘制空心线条</span></div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>效果展示图片：</p>
<p><img src="http://img.blog.csdn.net/20151104234836789?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="LockView"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如今很多涉及到安全方面的app都会有手势解锁这个功能。这个功能看似简单，其实还是有很多的注意点在里面。以下是我写的一个简单的手势解锁。&lt;/p&gt;
&lt;p&gt;如果你需要改变根控制器的view，你可以自定义，我这边简单定义了一下：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  BGView.m&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  05-手势解锁&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  Created by styshy on 15/11/4.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  Copyright (c) 2015年 sz. All rights reserved.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&quot;BGView.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BGView&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在drawRect中绘制图片&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)drawRect:(&lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt;)rect&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; *image = [&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageNamed:&lt;span class=&quot;string&quot;&gt;@&quot;Home_refresh_bg&quot;&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [image drawInRect:rect];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="自定义库" scheme="http://sz8023.github.io/categories/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>SDWebImage学习</title>
    <link href="http://sz8023.github.io/2015/09/01/SDWebImage%E5%AD%A6%E4%B9%A0/"/>
    <id>http://sz8023.github.io/2015/09/01/SDWebImage学习/</id>
    <published>2015-08-31T23:42:53.000Z</published>
    <updated>2016-09-01T01:32:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="rs-SDWebImage"><a href="#rs-SDWebImage" class="headerlink" title="rs/SDWebImage"></a><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">rs/SDWebImage</a></h3><p><code>SDWebImage</code>是一个优秀的图片处理框架，你可以通过它来实现异步图片下载，并且支持图片的缓存。</p>
<p>这个第三方库为UIImageView提供了一个分类，支持处理来自网络的图片，主要功能包括以下几点：</p>
<ul>
<li>一个UIImageView的分类来添加图片和缓存处理</li>
<li>一个异步图片下载器</li>
<li>一个异步内存和磁盘图片缓存和对缓存过期的处理</li>
<li>支持Gif图片</li>
<li>支持WebP</li>
<li>背景图片解压</li>
<li>相同URL的图片不会下载多次</li>
<li>假的URL不会尝试一直请求</li>
<li>保证主线程不会卡死</li>
<li>……</li>
</ul>
<h3 id="应该如何使用"><a href="#应该如何使用" class="headerlink" title="应该如何使用"></a>应该如何使用</h3><p><code>SDWebImage</code>为使用者提供了<a href="http://cocoadocs.org/docsets/SDWebImage/3.8.1/" target="_blank" rel="external">API document</a>，以下只是简单列举以下最常见的用法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;SDWebImage/UIImageView+WebCache.h&gt;</span></span></div><div class="line">...</div><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">   <span class="keyword">static</span> <span class="built_in">NSString</span> *MyIdentifier = <span class="string">@"MyIdentifier"</span>;</div><div class="line"></div><div class="line">   <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];</div><div class="line">   <span class="keyword">if</span> (cell == <span class="literal">nil</span>) &#123;</div><div class="line">       cell = [[[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span></div><div class="line">                                      reuseIdentifier:MyIdentifier] autorelease];</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// Here we use the new provided sd_setImageWithURL: method to load the web image</span></div><div class="line">   [cell.imageView sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</div><div class="line">                     placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]];</div><div class="line"></div><div class="line">   cell.textLabel.text = <span class="string">@"My Text"</span>;</div><div class="line">   <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>或者通过使用block的形式</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Here we use the new provided sd_setImageWithURL: method to load the web image</span></div><div class="line">[cell.imageView sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</div><div class="line">                      placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]</div><div class="line">                             completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">                                ... completion code here ...</div><div class="line">                             &#125;];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;rs-SDWebImage&quot;&gt;&lt;a href=&quot;#rs-SDWebImage&quot; class=&quot;headerlink&quot; title=&quot;rs/SDWebImage&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/rs/SDWebImage&quot;&gt;rs/SDWebImage&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt;是一个优秀的图片处理框架，你可以通过它来实现异步图片下载，并且支持图片的缓存。&lt;/p&gt;
&lt;p&gt;这个第三方库为UIImageView提供了一个分类，支持处理来自网络的图片，主要功能包括以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个UIImageView的分类来添加图片和缓存处理&lt;/li&gt;
&lt;li&gt;一个异步图片下载器&lt;/li&gt;
&lt;li&gt;一个异步内存和磁盘图片缓存和对缓存过期的处理&lt;/li&gt;
&lt;li&gt;支持Gif图片&lt;/li&gt;
&lt;li&gt;支持WebP&lt;/li&gt;
&lt;li&gt;背景图片解压&lt;/li&gt;
&lt;li&gt;相同URL的图片不会下载多次&lt;/li&gt;
&lt;li&gt;假的URL不会尝试一直请求&lt;/li&gt;
&lt;li&gt;保证主线程不会卡死&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;应该如何使用&quot;&gt;&lt;a href=&quot;#应该如何使用&quot; class=&quot;headerlink&quot; title=&quot;应该如何使用&quot;&gt;&lt;/a&gt;应该如何使用&lt;/h3&gt;&lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt;为使用者提供了&lt;a href=&quot;http://cocoadocs.org/docsets/SDWebImage/3.8.1/&quot;&gt;API document&lt;/a&gt;，以下只是简单列举以下最常见的用法。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;SDWebImage/UIImageView+WebCache.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; *)tableView:(&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *)tableView cellForRowAtIndexPath:(&lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *)indexPath &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *MyIdentifier = &lt;span class=&quot;string&quot;&gt;@&quot;MyIdentifier&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cell == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       cell = [[[&lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; alloc] initWithStyle:&lt;span class=&quot;built_in&quot;&gt;UITableViewCellStyleDefault&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                      reuseIdentifier:MyIdentifier] autorelease];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// Here we use the new provided sd_setImageWithURL: method to load the web image&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   [cell.imageView sd_setImageWithURL:[&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;http://www.domain.com/path/to/image.jpg&quot;&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                     placeholderImage:[&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageNamed:&lt;span class=&quot;string&quot;&gt;@&quot;placeholder.png&quot;&lt;/span&gt;]];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   cell.textLabel.text = &lt;span class=&quot;string&quot;&gt;@&quot;My Text&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; cell;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="框架学习" scheme="http://sz8023.github.io/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>MJExtension学习</title>
    <link href="http://sz8023.github.io/2015/07/05/MJExtension%E5%AD%A6%E4%B9%A0/"/>
    <id>http://sz8023.github.io/2015/07/05/MJExtension学习/</id>
    <published>2015-07-05T10:24:10.000Z</published>
    <updated>2016-08-31T12:57:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CoderMJLee-MJExtension"><a href="#CoderMJLee-MJExtension" class="headerlink" title="CoderMJLee/MJExtension"></a><a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="external">CoderMJLee/MJExtension</a></h3><p>大神李明杰的另一个框架，实现Json和Model的互相转换，转换速度快、使用简单方便的字典转模型框架。</p>
<p><code>MJExtension</code>是一套字典和模型之间转换的超轻量级框架</p>
<ul>
<li>JSON –&gt; Model、Core Data Modal</li>
<li>JSONString –&gt; Model、Core Data Model</li>
<li>Model、Core Data Model –&gt; JSON</li>
<li>JSON Array –&gt; Model Array、Core Data Model Array</li>
<li>JSONString –&gt; Model Array、Core Data Model Array</li>
<li>Model Array、Core Data Model Array –&gt; JSON Array</li>
</ul>
<p>Coding all properties of model in one line code.<br>只需要一行代码，就能实现模型的所有属性进行Coding(归档和解档)</p>
<p>同样的，MJExtension也提供了两种使用方式，一种是通过CocoaPods，另一种是通过手动导入的方式。</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CoderMJLee-MJExtension&quot;&gt;&lt;a href=&quot;#CoderMJLee-MJExtension&quot; class=&quot;headerlink&quot; title=&quot;CoderMJLee/MJExtension&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/CoderMJLee/MJExtension&quot;&gt;CoderMJLee/MJExtension&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;大神李明杰的另一个框架，实现Json和Model的互相转换，转换速度快、使用简单方便的字典转模型框架。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MJExtension&lt;/code&gt;是一套字典和模型之间转换的超轻量级框架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSON –&amp;gt; Model、Core Data Modal&lt;/li&gt;
&lt;li&gt;JSONString –&amp;gt; Model、Core Data Model&lt;/li&gt;
&lt;li&gt;Model、Core Data Model –&amp;gt; JSON&lt;/li&gt;
&lt;li&gt;JSON Array –&amp;gt; Model Array、Core Data Model Array&lt;/li&gt;
&lt;li&gt;JSONString –&amp;gt; Model Array、Core Data Model Array&lt;/li&gt;
&lt;li&gt;Model Array、Core Data Model Array –&amp;gt; JSON Array&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Coding all properties of model in one line code.&lt;br&gt;只需要一行代码，就能实现模型的所有属性进行Coding(归档和解档)&lt;/p&gt;
&lt;p&gt;同样的，MJExtension也提供了两种使用方式，一种是通过CocoaPods，另一种是通过手动导入的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="框架学习" scheme="http://sz8023.github.io/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>MJRefresh学习</title>
    <link href="http://sz8023.github.io/2015/06/30/MJRefresh%E5%AD%A6%E4%B9%A0/"/>
    <id>http://sz8023.github.io/2015/06/30/MJRefresh学习/</id>
    <published>2015-06-30T02:41:24.000Z</published>
    <updated>2016-08-31T10:22:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CoderMJLee-MJRefresh"><a href="#CoderMJLee-MJRefresh" class="headerlink" title="CoderMJLee/MJRefresh"></a><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="external">CoderMJLee/MJRefresh</a></h3><p>大神李明杰写的一个刷新控件造福了国内的一批程序员，也提高了我们开发项目的进度。</p>
<p><code>MJRefresh</code>的使用方式特别的简单，看看官网你就可以知道如何使用了。</p>
<p><code>MJRefresh</code>支持的刷新控件有：</p>
<ul>
<li>UIScrollView</li>
<li>UITableView</li>
<li>UICollectionView</li>
<li>UIWebView</li>
</ul>
<p>像很多牛逼的第三方一样，<code>MJRefresh</code>也提供了两种使用方式，你可以通过CocoaPods或者手动导入的方式来使用它。</p>
<h3 id="MJRefresh框架的结构图"><a href="#MJRefresh框架的结构图" class="headerlink" title="MJRefresh框架的结构图"></a>MJRefresh框架的结构图</h3><p><img src="../images/MJRefresh.png" width="800px"></p>
<p>使用者可以从这个结构图中清晰的看到自己想要使用的Class，甚至可以根据相应的结构来自己定义刷新控件。</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CoderMJLee-MJRefresh&quot;&gt;&lt;a href=&quot;#CoderMJLee-MJRefresh&quot; class=&quot;headerlink&quot; title=&quot;CoderMJLee/MJRefresh&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/CoderMJLee/MJRefresh&quot;&gt;CoderMJLee/MJRefresh&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;大神李明杰写的一个刷新控件造福了国内的一批程序员，也提高了我们开发项目的进度。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MJRefresh&lt;/code&gt;的使用方式特别的简单，看看官网你就可以知道如何使用了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MJRefresh&lt;/code&gt;支持的刷新控件有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UIScrollView&lt;/li&gt;
&lt;li&gt;UITableView&lt;/li&gt;
&lt;li&gt;UICollectionView&lt;/li&gt;
&lt;li&gt;UIWebView&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;像很多牛逼的第三方一样，&lt;code&gt;MJRefresh&lt;/code&gt;也提供了两种使用方式，你可以通过CocoaPods或者手动导入的方式来使用它。&lt;/p&gt;
&lt;h3 id=&quot;MJRefresh框架的结构图&quot;&gt;&lt;a href=&quot;#MJRefresh框架的结构图&quot; class=&quot;headerlink&quot; title=&quot;MJRefresh框架的结构图&quot;&gt;&lt;/a&gt;MJRefresh框架的结构图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;../images/MJRefresh.png&quot; width=800px&gt;&lt;/p&gt;
&lt;p&gt;使用者可以从这个结构图中清晰的看到自己想要使用的Class，甚至可以根据相应的结构来自己定义刷新控件。&lt;/p&gt;
    
    </summary>
    
      <category term="框架学习" scheme="http://sz8023.github.io/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Ruby教程</title>
    <link href="http://sz8023.github.io/2015/05/01/Ruby%E6%95%99%E7%A8%8B/"/>
    <id>http://sz8023.github.io/2015/05/01/Ruby教程/</id>
    <published>2015-05-01T01:46:31.000Z</published>
    <updated>2016-08-31T10:02:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Ruby教程"><a href="#Ruby教程" class="headerlink" title="Ruby教程"></a>Ruby教程</h3><p>Ruby是一种开源的面向对象程序设计的服务器端脚本语言。Ruby可运行于多种平台，如Windowss、MAC OS和UNIX的各种版本。</p>
<h3 id="编译-执行Ruby程序"><a href="#编译-执行Ruby程序" class="headerlink" title="编译/执行Ruby程序"></a>编译/执行Ruby程序</h3><p>Ruby与Smalltalk一样，是一个完美的面向对象语言，使用Ruby的语法比使用Smalltalk的语法要容易多。</p>
<h3 id="Ruby的特性"><a href="#Ruby的特性" class="headerlink" title="Ruby的特性"></a>Ruby的特性</h3><ul>
<li>Ruby是开源的，在Web上是免费提供的，但需要一个许可证。</li>
<li>Ruby是一种通用 、解释的编程语言。</li>
<li>Ruby是一种真正的面向对象编程语言。</li>
<li>Ruby是一种类似于Python和Perl的服务器端脚本语言</li>
<li>Ruby可以用来编写通用网关接口</li>
<li>Ruby可以被嵌套</li>
<li>……</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Ruby教程&quot;&gt;&lt;a href=&quot;#Ruby教程&quot; class=&quot;headerlink&quot; title=&quot;Ruby教程&quot;&gt;&lt;/a&gt;Ruby教程&lt;/h3&gt;&lt;p&gt;Ruby是一种开源的面向对象程序设计的服务器端脚本语言。Ruby可运行于多种平台，如Windowss、MAC
    
    </summary>
    
      <category term="Ruby教程" scheme="http://sz8023.github.io/categories/Ruby%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>NPM使用介绍</title>
    <link href="http://sz8023.github.io/2015/04/26/NPM%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://sz8023.github.io/2015/04/26/NPM使用介绍/</id>
    <published>2015-04-26T01:08:19.000Z</published>
    <updated>2016-08-31T10:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js-PEPL-交互式解释器"><a href="#Node-js-PEPL-交互式解释器" class="headerlink" title="Node.js PEPL(交互式解释器)"></a>Node.js PEPL(交互式解释器)</h1><p>我们可以在终端输入命令，并接收系统的响应<br>Node自带了交互式解释器，可以执行如下任务</p>
<ul>
<li>读取 - 读取用户输入，解析输入了JavaScript数据结构并存储在内存中</li>
<li>执行 - 执行输入的用户结构</li>
<li>打印 - 输出结果</li>
<li>循环 - 循环操作以上步骤知道用户两次按下ctrl+c 按钮退出</li>
</ul>
<p>我们可以输入以下命令来启动Node终端</p>
<pre><code>$ node
&gt;
</code></pre><h2 id="Node-js回调函数"><a href="#Node-js回调函数" class="headerlink" title="Node.js回调函数"></a>Node.js回调函数</h2><ul>
<li>Node.js异步编程的直接体现就是回调</li>
<li>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。</li>
<li>回调函数在完成任务之后就会被调用，Node使用了大量的回调函数，Node所有的API都支持回调函数。</li>
</ul>
<h3 id="阻塞代码"><a href="#阻塞代码" class="headerlink" title="阻塞代码"></a>阻塞代码</h3><pre><code>var fs = require(&quot;fs&quot;);
var data = fs.readFileSync(&apos;input.txt&apos;);

console.log(data.toString());
console.log(&quot;程序执行结束&quot;);
</code></pre><h3 id="非阻塞代码"><a href="#非阻塞代码" class="headerlink" title="非阻塞代码"></a>非阻塞代码</h3><pre><code>var fs = require(&quot;fs&quot;);

fs.readFile(&apos;input.txt&apos;,function(err,data) {
    if(err) return console.error(err);
    console.log(data.toString());
});

console.log(&quot;程序执行结束&quot;);
</code></pre><p><em>第一个实例在文件读取之后才执行程序。第二个实例我们不需要等待文件读取完成，这样就可以在读取文件的同时执行接下来的代码</em></p>
<h3 id="Node-js事件循环"><a href="#Node-js事件循环" class="headerlink" title="Node.js事件循环"></a>Node.js事件循环</h3><ul>
<li>Node.js是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。</li>
<li>Node.js的每一个API都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。</li>
<li>Node.js基本上所有的事件机制都是通过设计模式中的观察者模式实现</li>
<li>Node.js单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数。</li>
</ul>
<h3 id="随便"><a href="#随便" class="headerlink" title="随便"></a>随便</h3><pre><code>小到一个变量，数组，大到一个数据库或者网络通信，都离不开数据的增删改查。变量有，数据库也有。网络通信也有。GET,PUT,DELETE,POST
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Node-js-PEPL-交互式解释器&quot;&gt;&lt;a href=&quot;#Node-js-PEPL-交互式解释器&quot; class=&quot;headerlink&quot; title=&quot;Node.js PEPL(交互式解释器)&quot;&gt;&lt;/a&gt;Node.js PEPL(交互式解释器)&lt;/h1&gt;&lt;p&gt;
    
    </summary>
    
      <category term="Node教程" scheme="http://sz8023.github.io/categories/Node%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Node.js笔记</title>
    <link href="http://sz8023.github.io/2015/04/25/Node%E6%95%99%E7%A8%8B/"/>
    <id>http://sz8023.github.io/2015/04/25/Node教程/</id>
    <published>2015-04-25T09:26:39.000Z</published>
    <updated>2016-08-31T12:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js应用有哪几部分组成"><a href="#Node-js应用有哪几部分组成" class="headerlink" title="Node.js应用有哪几部分组成"></a>Node.js应用有哪几部分组成</h1><ul>
<li>引入require模块：</li>
<li>创建服务器：服务器可以监听客户端的请求</li>
<li>接收请求与相应请求</li>
</ul>
<h2 id="创建node-js应用"><a href="#创建node-js应用" class="headerlink" title="创建node.js应用"></a>创建node.js应用</h2><ol>
<li>我们使用require</li>
</ol>
<h3 id="NPM使用介绍"><a href="#NPM使用介绍" class="headerlink" title="NPM使用介绍"></a>NPM使用介绍</h3><p>NPM(Node Package Manager)是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景如下</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用</li>
<li>允许用户从NPM服务器下载并安装别人编写好的命令行程序到本地使用</li>
<li>允许用户将自己编写好的包或命令行程序上传到NPM服务器供别人使用</li>
</ul>
<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><ul>
<li>简单的说Node.js是运行在服务器端的JavaScript</li>
<li>Node.js是一个事件驱动I/O服务器端JavaScript环境，基于Google的V8引擎，V8引擎执行JavaScript的速度非常快，性能非常快</li>
</ul>
<h2 id="使用版本"><a href="#使用版本" class="headerlink" title="使用版本"></a>使用版本</h2><p>我们可以使用一下命令来查看当前的Node版本</p>
<pre><code>node -v 
</code></pre><p>Note:不同版本可能有差异的</p>
<h3 id="脚本模式"><a href="#脚本模式" class="headerlink" title="脚本模式"></a>脚本模式</h3><pre><code>console.log(&quot;Hello, World&quot;);
</code></pre><h3 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h3><h1 id="什么是Web服务器"><a href="#什么是Web服务器" class="headerlink" title="什么是Web服务器"></a>什么是Web服务器</h1><p><code>Web服务器</code>一般指的是网站服务器，是指驻留在因特网上某种类型的计算机的程序，<code>Web服务器</code>的基本功能就是提供Web信息浏览功能服务。</p>
<p><strong>Web架构</strong><br><!--![web_architecture](../images/web_architecture.jpg)--></p>
<p><img src="../images/web_architecture.jpg" width="600px"></p>
<a id="more"></a>
<h3 id="使用Node创建Web服务"><a href="#使用Node创建Web服务" class="headerlink" title="使用Node创建Web服务"></a>使用Node创建Web服务</h3><p>Node.js提供了http模块，http模块主要用于搭建HTTP服务器和客户端，使用HTTP服务器或客户端功能必须调用HTTP模块。代码如下</p>
<pre><code>var http = require(&apos;http&apos;);
</code></pre><h3 id="使用Node创建Web客户端"><a href="#使用Node创建Web客户端" class="headerlink" title="使用Node创建Web客户端"></a>使用Node创建Web客户端</h3><p>Node.js创建Web客户端需要引入http模块，创建client.js文件，代码如下所示：    </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Node-js应用有哪几部分组成&quot;&gt;&lt;a href=&quot;#Node-js应用有哪几部分组成&quot; class=&quot;headerlink&quot; title=&quot;Node.js应用有哪几部分组成&quot;&gt;&lt;/a&gt;Node.js应用有哪几部分组成&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;引入require模块：&lt;/li&gt;
&lt;li&gt;创建服务器：服务器可以监听客户端的请求&lt;/li&gt;
&lt;li&gt;接收请求与相应请求&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;创建node-js应用&quot;&gt;&lt;a href=&quot;#创建node-js应用&quot; class=&quot;headerlink&quot; title=&quot;创建node.js应用&quot;&gt;&lt;/a&gt;创建node.js应用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;我们使用require&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;NPM使用介绍&quot;&gt;&lt;a href=&quot;#NPM使用介绍&quot; class=&quot;headerlink&quot; title=&quot;NPM使用介绍&quot;&gt;&lt;/a&gt;NPM使用介绍&lt;/h3&gt;&lt;p&gt;NPM(Node Package Manager)是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许用户从NPM服务器下载别人编写的第三方包到本地使用&lt;/li&gt;
&lt;li&gt;允许用户从NPM服务器下载并安装别人编写好的命令行程序到本地使用&lt;/li&gt;
&lt;li&gt;允许用户将自己编写好的包或命令行程序上传到NPM服务器供别人使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Node-js&quot;&gt;&lt;a href=&quot;#Node-js&quot; class=&quot;headerlink&quot; title=&quot;Node.js&quot;&gt;&lt;/a&gt;Node.js&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;简单的说Node.js是运行在服务器端的JavaScript&lt;/li&gt;
&lt;li&gt;Node.js是一个事件驱动I/O服务器端JavaScript环境，基于Google的V8引擎，V8引擎执行JavaScript的速度非常快，性能非常快&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;使用版本&quot;&gt;&lt;a href=&quot;#使用版本&quot; class=&quot;headerlink&quot; title=&quot;使用版本&quot;&gt;&lt;/a&gt;使用版本&lt;/h2&gt;&lt;p&gt;我们可以使用一下命令来查看当前的Node版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node -v 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note:不同版本可能有差异的&lt;/p&gt;
&lt;h3 id=&quot;脚本模式&quot;&gt;&lt;a href=&quot;#脚本模式&quot; class=&quot;headerlink&quot; title=&quot;脚本模式&quot;&gt;&lt;/a&gt;脚本模式&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;console.log(&amp;quot;Hello, World&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;交互模式&quot;&gt;&lt;a href=&quot;#交互模式&quot; class=&quot;headerlink&quot; title=&quot;交互模式&quot;&gt;&lt;/a&gt;交互模式&lt;/h3&gt;&lt;h1 id=&quot;什么是Web服务器&quot;&gt;&lt;a href=&quot;#什么是Web服务器&quot; class=&quot;headerlink&quot; title=&quot;什么是Web服务器&quot;&gt;&lt;/a&gt;什么是Web服务器&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Web服务器&lt;/code&gt;一般指的是网站服务器，是指驻留在因特网上某种类型的计算机的程序，&lt;code&gt;Web服务器&lt;/code&gt;的基本功能就是提供Web信息浏览功能服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Web架构&lt;/strong&gt;&lt;br&gt;&lt;!--![web_architecture](../images/web_architecture.jpg)--&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/web_architecture.jpg&quot; width=600px &gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Node教程" scheme="http://sz8023.github.io/categories/Node%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>HTML5教程</title>
    <link href="http://sz8023.github.io/2015/03/02/Html5%E6%95%99%E7%A8%8B/"/>
    <id>http://sz8023.github.io/2015/03/02/Html5教程/</id>
    <published>2015-03-02T05:42:39.000Z</published>
    <updated>2016-08-31T10:02:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML5教程"><a href="#HTML5教程" class="headerlink" title="HTML5教程"></a>HTML5教程</h3><p>你可以使用HTML来创建自己的WEB站点。<br>HTML5是HTML最新的修订版，HTML5的设计目的是为了在<strong>移动设备上支持多媒体。</strong></p>
<p>HTML5是W3C与WHATWG合作的结果。<br>WHATWG致力于web表单和应用程序，而W3C专注于XHTML2.0。</p>
<p>HTML5中的一些有趣的新特性：</p>
<ul>
<li>用于会话的canvas元素</li>
<li>用于媒介回放的video和audio元素</li>
<li>对本地离线存储的跟好的支持</li>
<li>新的特殊内容元素，比如article、footer、header、nav、section</li>
<li>新的表单控件，比如calendar、date、time、email、url、search</li>
</ul>
<a id="more"></a>
<h3 id="HTML5-lt-DOCTYPE-gt"><a href="#HTML5-lt-DOCTYPE-gt" class="headerlink" title="HTML5&lt;!DOCTYPE&gt;"></a>HTML5&lt;!DOCTYPE&gt;</h3><p>&lt;!DOCTYPE&gt;声明必须位于HTML5文档中的第一行，使用非常简单。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div></pre></td></tr></table></figure>
<h3 id="HTML5浏览器支持"><a href="#HTML5浏览器支持" class="headerlink" title="HTML5浏览器支持"></a>HTML5浏览器支持</h3><p>最新版的Safari、Chrome、Firefox以及Opera支持某些HTML5特性。Internet Explorer 9将支持某些HTML5特性。</p>
<p><img src="../images/browsers_say.png" alt="支持哪些浏览器"></p>
<p>不论旧的和最新的浏览器，对无法识别的元素会作为内联元素自动处理。正因为如此，你可以“教会”浏览器处理“未知”的HTML元素。</p>
<h3 id="HTML5新元素"><a href="#HTML5新元素" class="headerlink" title="HTML5新元素"></a>HTML5新元素</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTML5教程&quot;&gt;&lt;a href=&quot;#HTML5教程&quot; class=&quot;headerlink&quot; title=&quot;HTML5教程&quot;&gt;&lt;/a&gt;HTML5教程&lt;/h3&gt;&lt;p&gt;你可以使用HTML来创建自己的WEB站点。&lt;br&gt;HTML5是HTML最新的修订版，HTML5的设计目的是为了在&lt;strong&gt;移动设备上支持多媒体。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTML5是W3C与WHATWG合作的结果。&lt;br&gt;WHATWG致力于web表单和应用程序，而W3C专注于XHTML2.0。&lt;/p&gt;
&lt;p&gt;HTML5中的一些有趣的新特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于会话的canvas元素&lt;/li&gt;
&lt;li&gt;用于媒介回放的video和audio元素&lt;/li&gt;
&lt;li&gt;对本地离线存储的跟好的支持&lt;/li&gt;
&lt;li&gt;新的特殊内容元素，比如article、footer、header、nav、section&lt;/li&gt;
&lt;li&gt;新的表单控件，比如calendar、date、time、email、url、search&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="HTML5教程" scheme="http://sz8023.github.io/categories/HTML5%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello,Hexo</title>
    <link href="http://sz8023.github.io/2015/02/25/Hexo%E6%95%99%E7%A8%8B/"/>
    <id>http://sz8023.github.io/2015/02/25/Hexo教程/</id>
    <published>2015-02-25T06:16:30.000Z</published>
    <updated>2016-08-31T10:02:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
      <category term="Hexo教程" scheme="http://sz8023.github.io/categories/Hexo%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
</feed>
